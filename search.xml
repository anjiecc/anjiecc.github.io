<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>TypeScript入门教程(四) - 类</title>
      <link href="/2018/10/07/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%9B%9B)%20-%20%E7%B1%BB/"/>
      <url>/2018/10/07/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%9B%9B)%20-%20%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>在传统<code>JavaScript</code>中类是基于原型模拟出来的类，在ES6中新增<code>class</code>关键字来书写基于类的面向对象(底层还是基于原型的方式)<br><a id="more"></a></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><blockquote><p>维基百科 -&gt; 在面向对象编程，类（英语：class）是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法</p></blockquote><ul><li>ES5中的模拟类:</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Fn1.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Fn1,</span><br><span class="line">    setAge: function(<span class="params">age</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ES6中的类</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    setAge(age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TypeScript中的类</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    setAge(age: <span class="built_in">number</span>): <span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    setAge(age: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Fn2 <span class="keyword">extends</span> Fn1&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="keyword">new</span> Fn2(<span class="string">'mickey'</span>, <span class="number">26</span>)</span><br><span class="line">fn1.setAge(<span class="number">27</span>) <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>继承我们可以通过关键字<code>extends</code>来继承</p><p>ES5中的继承方式推荐大家看一下阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">构造函数的继承</a></p><h3 id="public修饰符"><a href="#public修饰符" class="headerlink" title="public修饰符"></a>public修饰符</h3><p>C#要求必须明确地使用 public指定成员是可见的。 在TypeScript里，成员都默认为 public</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> setAge(age: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private修饰符"><a href="#private修饰符" class="headerlink" title="private修饰符"></a>private修饰符</h3><p>当成员被标记成 private时，它就不能在声明它的类的外部访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Fn1().name <span class="comment">// error 'name'是私有的</span></span><br></pre></td></tr></table></figure><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Fn2 <span class="keyword">extends</span> Fn1&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">       <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Fn2(<span class="string">'mickey'</span>).name <span class="comment">// error </span></span><br><span class="line"><span class="keyword">new</span> Fn2(<span class="string">'mickey'</span>).getName() <span class="comment">// mickey</span></span><br></pre></td></tr></table></figure><p><strong>我们不能在Fn1类外使用name，但是我们可以在派生出来的实例方法上使用name</strong></p><h3 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h3><p>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fn2(<span class="string">'mickey'</span>)</span><br><span class="line">f.name = <span class="string">'xxx'</span> <span class="comment">// error name是只读</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">    getName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码我们通过在<code>constructor</code>参数<code>private name: string</code>来进行创建和初始化,我们就声明和赋值合并在一起了，public和 protected的使用也是一样</p><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">"secret passcode"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">"secret passcode"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Error: Unauthorized update of employee!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    alert(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有<code>get</code>不带有<code>set</code>的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值</p><h3 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h3><p>我们可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Styles &#123;</span><br><span class="line">    <span class="keyword">static</span> width = <span class="number">200</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> style: object</span>) &#123;&#125;</span><br><span class="line">    getWidth() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Styles.width) <span class="comment">// 200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Styles(&#123;height: <span class="number">200</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Department &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printName(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Department name: '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span>; <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AccountingDepartment <span class="keyword">extends</span> Department &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'Accounting and Auditing'</span>); <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMeeting(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'The Accounting Department meets each Monday at 10am.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generateReports(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Generating accounting reports...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> department: Department; <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> Department(); <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment(); <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.printName();</span><br><span class="line">department.printMeeting();</span><br><span class="line">department.generateReports(); <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的类，第五节我们将介绍函数</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a><br><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">阮一峰Es6</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(三) - 接口</title>
      <link href="/2018/10/06/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%89)%20-%20%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/10/06/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%89)%20-%20%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约<br><a id="more"></a></p><h3 id="初次见面接口"><a href="#初次见面接口" class="headerlink" title="初次见面接口"></a>初次见面接口</h3><p>先看一段实例代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">styles: &#123;wdith: <span class="built_in">number</span>&#125;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(styles.wdith)</span><br><span class="line">&#125;</span><br><span class="line">fn1(&#123;width: <span class="number">100</span>, height: <span class="number">200</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码函数接受一个参数名<code>styles</code>里面有属性<code>width</code>类型是<code>number</code>,但是我们传了其他属性，编译器只会检查那些必需的属性是否存在，然而，有些时候TypeScript却并不会这么宽松</p><p>我们修改一下上面的例子，通过接口在实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">styles: Styles</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(styles.wdith)</span><br><span class="line">&#125;</span><br><span class="line">fn1(&#123;width: <span class="number">100</span>, height: <span class="number">200</span>&#125;) <span class="comment">// 这里会报错说height没有定义在接口中</span></span><br></pre></td></tr></table></figure><p><code>Styles</code>接口就是名字，用来描述上面例子里面的需求，它表示有一个<code>width</code>属性类型为<code>number</code>， 需要注意的是，我们在这里并不能像在其它语言里一样，说传给<code>fn1</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的</p><p><strong>类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以</strong></p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里面的属性不全部是必须的，我们可以不传一些参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span>,</span><br><span class="line">    height?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">styles: Styles</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(style)</span><br><span class="line">&#125;</span><br><span class="line">fn1(&#123;width: <span class="number">100</span>&#125;) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只是只读，你不能修改它的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    readonly width: <span class="built_in">number</span>,</span><br><span class="line">    readonly height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> styles: Styles = &#123;width: <span class="number">100</span>, height: <span class="number">200</span>&#125;</span><br><span class="line">styles.width = <span class="number">200</span> <span class="comment">// error widht是只读属性不能修改</span></span><br></pre></td></tr></table></figure><p>数组也可以创建只读，TypeScript具有ReadonlyArray<t>类型，可以确保数组创建后再也不能被修改：</t></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list1: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">list1 = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1 = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口可以描述对象也可以描述函数类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> fn1 &#123;</span><br><span class="line">    (width: <span class="built_in">number</span>, height: <span class="built_in">number</span>): object&lt;&#123;width: <span class="built_in">number</span>, height: <span class="built_in">number</span>&#125;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们定义了一个函数类型的接口，下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stylesFn: fn1</span><br><span class="line">stylesFn =  <span class="function"><span class="keyword">function</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; width,height &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如styles[0]或styles[“width”],可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> styles: Styles</span><br><span class="line">styles = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"><span class="keyword">let</span> width: <span class="built_in">number</span> = styles[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span>,</span><br><span class="line">    setStyle(s: object)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> CreateStyles <span class="keyword">implements</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    setStyle(s: object): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承，我们可以从一个接口复制成员到另一个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Styles1 <span class="keyword">extends</span> Styles &#123;</span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = &lt;Styles1&gt;&#123;&#125;</span><br><span class="line">s.color = <span class="string">'red'</span></span><br><span class="line">s.width = <span class="number">100</span></span><br><span class="line">s.height = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>接口可以继承多个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Styles1 &#123;</span><br><span class="line">    border: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Styles2 <span class="keyword">extends</span> Styles, Styles1&#123;</span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = &lt;Styles2&gt;&#123;&#125;</span><br><span class="line">s.color = <span class="string">'red'</span></span><br><span class="line">s.width = <span class="number">100</span></span><br><span class="line">s.height = <span class="number">200</span></span><br><span class="line">s.border = <span class="string">'1px solid red'</span></span><br></pre></td></tr></table></figure><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>接口可以同时用于对象和函数使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    reset(): <span class="built_in">void</span></span><br><span class="line">    (style: object): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStyles</span>(<span class="params"></span>): <span class="title">Styles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> initStyle = &lt;Styles&gt;<span class="function"><span class="keyword">function</span>(<span class="params">style: object</span>)</span>&#123;&#125;</span><br><span class="line">    initStyle.width = <span class="number">200</span></span><br><span class="line">    initStyle.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用<code>JavaScript</code>第三方库的时候，你可能需要像上面那样去完整地定义类型</p><p>上面我们介绍了<code>TypeScript</code>的接口，第四节我们将介绍类</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(二) - 变量声明</title>
      <link href="/2018/10/05/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%BA%8C)%20-%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
      <url>/2018/10/05/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%BA%8C)%20-%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>在es5中js声明变量是通过<code>var</code>关键字进行变量声明，在es6中我们可以通过<code>let</code>,<code>const</code>两个关键字来进行声明，typescript中支持<code>let</code>,<code>const</code>进行声明变量<br><a id="more"></a></p><h3 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h3><p>在过去的js中(es5之前包括es5)我们声明变量是通过<code>var</code>来声明一个变量，但是var声明变量也有它不足的地方，我们接下来会详细介绍它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'mickey'</span></span><br></pre></td></tr></table></figure><p>通过上面的方式我们就声明了一个变量<code>a</code>类型是字符串值为<code>&#39;mickey&#39;</code><br>我们也可以在函数中声明变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是像<code>Java</code>,<code>C</code>等其他语言开发人员会对js中的var声明的变量作用域看起来很奇怪</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">flag: <span class="built_in">boolean</span></span>): <span class="title">void</span> | <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">26</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="literal">false</span>) <span class="comment">// return undefined</span></span><br><span class="line">fn1(<span class="literal">true</span>) <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>上面的例子中，变量<code>num</code>声明在<code>if</code>语句中，但是我们在语句的外面还是可以访问它，这是因为<code>var</code>声明可以包含在函数，模块，命名空间和全局作用域内部任何位置被访问，js通过var声明的变量是没有块级作用域</p><p>我们在看一个例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123; </span><br><span class="line">   a[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里我们点击a标签会输入 7</span></span><br><span class="line"><span class="comment">// 因为循环创建了i变量后面会直接覆盖前面的变量值</span></span><br></pre></td></tr></table></figure><p>为了解决上面的问题我们可以通过闭包来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i&lt;a.length; i++)&#123; </span><br><span class="line">   a[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(i);&#125;</span><br><span class="line">   &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方式通过es6中的<code>let</code>来解决,接下来我们详细介绍<code>let</code></p><h3 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h3><p>使用<code>let</code>和之前<code>var</code>声明变量一样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'mickey'</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = <span class="number">26</span></span><br></pre></td></tr></table></figure><p>我们通过<code>let</code>声明的方式解决上面的问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123; </span><br><span class="line">   a[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里我们点击a标签会输入 0,1,2,3,4,5,6,7</span></span><br></pre></td></tr></table></figure><p>如果你想了解比较详细<code>let</code>如果使用和新的特性你可以参考<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门-阮一峰</a></p><h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><p>使用<code>Const</code>和之前<code>var</code>声明变量一样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'mickey'</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">number</span> = <span class="number">26</span></span><br></pre></td></tr></table></figure><p>如果你想了解比较详细<code>Const</code>如果使用和新的特性你可以参考<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门-阮一峰</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><ul><li>数组解构</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">&#125;</span><br><span class="line">f(input);</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><ul><li>对象解构</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="string">"foo"</span>,</span><br><span class="line">    b: <span class="number">12</span>,</span><br><span class="line">    c: <span class="string">"bar"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; a, b &#125; = &#123; a: <span class="string">"baz"</span>, b: <span class="number">101</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面简单的介绍了数组解构和对象解构，如果你想详情了解还是推荐你去<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门-阮一峰</a>这个对ES6进行非常详细的介绍，相信你会学到很多ES6中所有新特性</p><p>上面我们介绍了<code>TypeScript</code>的变量声明，第三节我们将介绍接口</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(一) - 基础类型</title>
      <link href="/2018/10/04/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%80)%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/04/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%80)%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><code>Typescript</code>中的基础类型和<code>JavaScript</code>中定义的五种基本类型(<code>Number</code>,<code>String</code>,<code>Boolean</code>,<code>Undefined</code>,<code>Null</code>)几乎相同,还新增了枚举类型,接下来我们详细介绍<code>TypeScript</code>中的基础类型<br><a id="more"></a></p><h3 id="布尔值-Boolean"><a href="#布尔值-Boolean" class="headerlink" title="布尔值(Boolean)"></a>布尔值(Boolean)</h3><ul><li>布尔值类型就是简单的<code>true</code> or <code>false</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isShow: <span class="built_in">boolean</span> = <span class="literal">true</span> </span><br><span class="line"><span class="comment">// :后面是指定变量isShow的类型，如果修改了isShow的变量类型为非boolean值就会报错</span></span><br></pre></td></tr></table></figure><h3 id="数字-Number"><a href="#数字-Number" class="headerlink" title="数字(Number)"></a>数字(Number)</h3><ul><li><code>Typescript</code>中的数字类型和<code>Javascript</code>中的数字类型一样都是浮点数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">26</span></span><br><span class="line"><span class="keyword">let</span> money: <span class="built_in">number</span> = <span class="number">6000.04</span></span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span></span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span></span><br></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li><code>Typescript</code>中的字符串和<code>JavaScript</code>字符串写法一样都是通过双引号(<code>&quot;&quot;</code>)或者单引号(<code>&#39;&#39;</code>)表示字符串</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1: <span class="built_in">string</span> = <span class="string">'hi'</span></span><br><span class="line"><span class="keyword">let</span> str2: <span class="built_in">string</span> = <span class="string">"hi"</span></span><br></pre></td></tr></table></figure><h3 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h3><ul><li><code>Typescript</code>中<code>null</code>和<code>undefined</code>两个各自有自己的类型分别是<code>null</code>和<code>undefined</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// undefined和null是所有类型的子集，就是你可以把所有类型赋值成undefined和null</span></span><br></pre></td></tr></table></figure><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><ul><li><code>Typescript</code>里面的数组和JavaScript中一样都可以操作数组元素,在<code>Typescript</code>中有两种定义数组的方式</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一:</span></span><br><span class="line"><span class="keyword">let</span> list1: <span class="built_in">string</span>[] = [<span class="string">'name1'</span>, <span class="string">'name2'</span>, <span class="string">'name3'</span>]</span><br><span class="line"><span class="keyword">let</span> list2: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 方法二:</span></span><br><span class="line"><span class="keyword">let</span> list3: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'name1'</span>, <span class="string">'name2'</span>, <span class="string">'name3'</span>]</span><br><span class="line"><span class="keyword">let</span> list4: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h3><ul><li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">t = [<span class="string">'mickey'</span>, <span class="number">26</span>] <span class="comment">// ok</span></span><br><span class="line">t = [<span class="number">26</span>, <span class="string">'mickey'</span>] <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举(Enum)"></a>枚举(Enum)</h3><ul><li><code>enum</code>类型是在<code>JavaScript</code>类型中新增的类型, 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Style &#123;width, height, color&#125;</span><br><span class="line"><span class="keyword">let</span> warp: Style = Style.width</span><br></pre></td></tr></table></figure><p>默认情况下，枚举里面的值是从<code>0</code>开始为元素编号，也可以手动的指定成员的数值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Style &#123;width = <span class="number">1</span>, height = <span class="number">2</span>, color = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> wrap: Style = Style.width</span><br><span class="line"><span class="comment">// 也可以通过枚举的值得到它的名字</span></span><br><span class="line"><span class="keyword">let</span> wrap: Style = Style[<span class="number">2</span>] <span class="comment">// height</span></span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><ul><li>我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查就可以使用<code>any</code>类型来标记这些变量</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="string">'mickey'</span></span><br><span class="line">a = <span class="number">26</span></span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list1: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="number">1</span>,<span class="string">'name1'</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p><strong><em>通过any定义的变量在后面可以随意赋值成其他类型的变量,这个就和js使用一样，js是弱类型语言定义变量可以不指定类型而且可以随意修改变量类型</em></strong></p><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><ul><li>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test...'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量为void 你只能为它赋值为 undefined和null</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">void</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><ul><li>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时</li><li>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的基础类型，第二节我们将介绍变量声明</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js原型继承五条基本原则</title>
      <link href="/2017/08/23/js%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BA%94%E6%9D%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
      <url>/2017/08/23/js%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BA%94%E6%9D%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>js中的原型继承，遵守5个基本原则：</p><ul><li>所有的数据都是对象</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li></ul><p>接下来我们将详细讲解这个5个基本原则…..</p><a id="more"></a><h3 id="所有的数据都是对象"><a href="#所有的数据都是对象" class="headerlink" title="所有的数据都是对象"></a>所有的数据都是对象</h3><p>js在设计的时候引入了java两套类型机制：<strong>基本类型</strong>和<strong>引用类型</strong></p><p>基本类型包括：<code>undefined、number、boolean、string、function、object</code></p><p>我们不能说js中所有的数据都是对象，但是可以说绝大多数的数据都是对象，那么相信在js中也一定会存在一个根对象(<strong>Object.prototype</strong>)</p><p>在js中根对象(<strong>Object.prototype</strong>)是一个空的对象，我们遇到的每一个对象都是从<strong>Object.prototype</strong>对象克隆而来，<strong>Object.prototype</strong>对象就是它们的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj_1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj_2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Object.getPrototypeOf来查看它们的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj_1) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj_2) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"><a href="#要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它" class="headerlink" title="要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"></a>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</h3><p>在js中我们并不需要关心克隆的细节，因为这些操作浏览器引擎内部已经实现了，我们只需要显式地调用<code>var obj = new Object()或者var obj = {}</code>，引擎会从<code>Object.prototype</code>上克隆一个对象出来。</p><p>我们也可以通过new操作符来创建一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Person(<span class="string">'anjie'</span>); <span class="comment">// 通过new操作符得到一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r.name);<span class="comment">//anjie</span></span><br><span class="line"><span class="built_in">console</span>.log(r.getName());<span class="comment">//anjie</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(r) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>我们通过new得到的对象具体做了什么？</strong><br>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4<br>个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性；</li><li>返回新对象；</li></ol><p>new操作符具体做了3件事<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空对象</span></span><br><span class="line"><span class="keyword">var</span> r = &#123;&#125;; </span><br><span class="line"><span class="comment">//将这个空对象的__proto__成员指向了Person函数对象prototype成员对象</span></span><br><span class="line">r.__proto__ = Person.prototype  </span><br><span class="line"><span class="comment">//将Person函数对象的this指针替换成r，然后再调用Person函数,给r添加属性和方法</span></span><br><span class="line">Person.call(r)</span><br></pre></td></tr></table></figure></p><p><strong>模仿new操作符</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> simulationNew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 从Objecet.prototype克隆一个对象</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>); <span class="comment">// 获取外部参数</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;<span class="comment">//指向正确的原型</span></span><br><span class="line">    <span class="keyword">var</span> newObj = Constructor.apply(obj,<span class="built_in">arguments</span>); <span class="comment">//借用外部传入的构造器给obj设置属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> newObj === <span class="string">'object'</span> ? newObj : obj; <span class="comment">//确保返回的永远是一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = simulationNew(Person,<span class="string">'anjie'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.name);<span class="comment">//anjie</span></span><br><span class="line"><span class="built_in">console</span>.log(a.getName());<span class="comment">//anjie</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h3><p>js给对象提供了一个名为<code>__proto__</code>的隐藏属性，某个对象的<code>__proto__</code>属性默认会指向它的构造器的原型对象，即<code>{Constructor.prototype}</code>,在一些浏览器中，<code>__proto__</code>被公开出来了(Chrome/Firefox)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>__proto__</code>就是对象跟对象构造器的原型联系起来的桥梁，正因为对象通过<code>__proto__</code>来记住的构造器的原型，我们上面模拟new操作符需要手动的给obj对象设置正确的<code>__proto__</code>指向</p><h3 id="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"><a href="#如果对象无法响应某个请求，它会把这个请求委托给它自己的原型" class="headerlink" title="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"></a>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</h3><p>在js中，每个对象都是通过<code>Object.prototype</code>克隆出来的，如果是这样的话我们只能得到单一的继承关系，即每个对象都是继承自<code>Object.prototype</code>对象，这样的对象显然是非常受限的。</p><p>js对象最初都是由<code>Object.prototype</code>克隆而来，但是对象构造器的原型并不仅限于<code>Object.prototype</code>上，而是可以动态指向其他对象，这样一来，但对象a需要借用b对象的能力时，可以选择性的把对象a的原型指向对象b，从而达到继承的效果。</p><p><strong>下面的代码是我们常用的原型继承方式：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'anjie'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">A.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.name);<span class="comment">//anjie</span></span><br></pre></td></tr></table></figure><p><strong>上面的代码引擎内部做了什么？</strong></p><ul><li>遍历对象a中的所有属性，但是没有name这个属性</li><li>查找name属性的这个请求委托对象a的构造器的原型，它被<code>a.__proto__</code>记录着并且指向<code>A.prototype</code>,而<code>A.prototype</code>被设置为对象obj</li><li>在对象obj中找到name属性，并返回它的值</li></ul><p><strong>当我们期望得到一个类继承自另一个类时</strong>我们通常会使用下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    name:<span class="string">'anjie'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="built_in">console</span>.log(b.name);<span class="comment">//anjie</span></span><br></pre></td></tr></table></figure><p><strong>上面的代码引擎内部做了什么？</strong></p><ul><li>遍历对象a中的所有属性，但是没有name这个属性</li><li>查找name属性的这个请求委托对象b的构造器的原型，它被<code>b.__proto__</code>记录着并且指向<code>B.prototype</code>,而<code>B.prototype</code>被设置为通过<code>new A()</code>创建出来的对象</li><li>在该对象中依然没有找到name属性，于是请求将继续委托给这个对象构造器的原型<code>A.prototype</code></li><li>在<code>A.prototype</code>中找到name属性，并返回它的值</li></ul><p>如果<code>A.prototype</code>中还没有知道name属性，请求会被传递给<code>A.prototype</code>的原型<code>Object.prototype</code>，如果没有name属性，会继续传递给<code>Object.prototype</code>的原型，<code>Object.prototype</code>的原型是<code>null</code>,所以会返回<code>undefined</code></p><p>ES6的中带来了新的<code>Class</code>语法，让js看起来更加想一门基于类的语言，其实背后还是通过原型机制来实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class manPerson extends Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> manPerson(<span class="string">'anjie'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.getName());<span class="comment">//anjie</span></span><br></pre></td></tr></table></figure><p>总结就写到这里了，本文简单介绍了js中原型继承的机制，希望通过学习的我们的学习总结笔记让大家也有收获，如果有什么不对的地方，望大家指点出来，我们共同学习。</p>]]></content>
      
      
      <categories>
          
          <category> js原型继承 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式单例模式</title>
      <link href="/2017/08/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/08/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是一种常见的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等。在js开发中，单例模式的用途同样非常广泛……<br><a id="more"></a></p><h3 id="JavaScript-设计模式-单例模式"><a href="#JavaScript-设计模式-单例模式" class="headerlink" title="JavaScript 设计模式-单例模式"></a>JavaScript 设计模式-单例模式</h3><h3 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h3><ul><li>定义：<code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</code></li></ul><h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><ul><li>原理：<code>用一个变量来保存当前是否已经为某个类创建对象，如果创建了就直接返回该对象，反之就重新实例化</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fn = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">Fn.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Fn(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = Fn.getInstance(<span class="string">'xxx'</span>);</span><br><span class="line"><span class="keyword">var</span> b = Fn.getInstance(<span class="string">'ooo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="透明的单例模式"><a href="#透明的单例模式" class="headerlink" title="透明的单例模式"></a>透明的单例模式</h3><p>我们创建一个CreateDiv单例类来负责在页面中创建唯一的div节点，实现一个<strong>‘透明’</strong>的单例类，用户从这个类中创建对象的时候，可以像使用任何普通类一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.html= html;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        <span class="keyword">return</span> instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> div = $(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>);</span><br><span class="line">        div.html(<span class="keyword">this</span>.html);</span><br><span class="line">        $(body).append(div);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CreateDiv;</span><br><span class="line">&#125;)()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> CreateDiv(<span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> CreateDiv(<span class="string">'two'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><pre><code>上面的代码实现了**透明**单例，但是也有它的缺点，上面我们使用了自执行函数和闭包，并且让这个匿名函数返回真正的构造函数，这样增加了一些程序的复杂度。如果某天我们需要利用这个类，在页面上创建很多个div，既要让这个单例类变成一个普通的可以产生多个实例，那我们就需要修改CreateDiv构造函数，把控制创建唯一对象的那段代码删除掉，这样就会刚给我带来一些不必要的麻烦，所有我们利用另外一种方式去实现，这种方式叫着**代理模式**,后面的笔记中我会详细介绍**代理模式**的具体实习方式</code></pre><h3 id="利用代理模式实现单例模式"><a href="#利用代理模式实现单例模式" class="headerlink" title="利用代理模式实现单例模式"></a>利用代理模式实现单例模式</h3><p>我们把上面的透明单例代码中间创建div部分代码移除出去，使他成为一个普通的创建DIV类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建div类</span></span><br><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.html = html;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = $(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>);</span><br><span class="line">    div.html(<span class="keyword">this</span>.html);</span><br><span class="line">    $(<span class="string">'body'</span>).append(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">var</span> ProxySingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CreateDiv(html);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ProxySingleton(<span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ProxySingleton(<span class="string">'two'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b );<span class="comment">//true</span></span><br></pre></td></tr></table></figure><pre><code>通过引入代理类的方式，我们也实现了单例模式，我们把负责管理单例的逻辑移到代理类**ProxySingleton**中，**CreateDiv**就变成一个普通类，它更**ProxySingleton**组合起来就可以实现单例模式的效果，这样的代码会更叫好维护。</code></pre><h3 id="JavaScript中的单例模式"><a href="#JavaScript中的单例模式" class="headerlink" title="JavaScript中的单例模式"></a>JavaScript中的单例模式</h3><ul><li>上面提到的创建单例模式，更多的是接近面向对象语言中的实现，单例对象从<strong>‘类’</strong>创建而来，在类为中心得语言中，这是很自然的做法。</li><li>在JavaScript中，其实是一门无类语言，没有类这个概念，在JS中创建单例模式方法很简单，我们只需要创建一个唯一的类。</li><li>全局变量不是单例模式，但是在js开发中，我们经常把全局变量当成单例模式来使用<h5 id="我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染"><a href="#我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染" class="headerlink" title="我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染"></a>我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染</h5></li></ul><ol><li><p>使用命名空间</p><h6 id="使用对象字面量的方式来创建："><a href="#使用对象字面量的方式来创建：" class="headerlink" title="使用对象字面量的方式来创建："></a>使用对象字面量的方式来创建：</h6> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = &#123;</span><br><span class="line">    a:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="使用动态创建命名空间"><a href="#使用动态创建命名空间" class="headerlink" title="使用动态创建命名空间"></a>使用动态创建命名空间</h6> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> My = &#123;&#125;;</span><br><span class="line">My.name = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parts = name.split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">var</span> current = My;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> parts)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!current[parts[i]])&#123;</span><br><span class="line">            current[parts[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current[parts[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">My.name = (<span class="string">'init'</span>);</span><br><span class="line">My.name = (<span class="string">'dom.style'</span>);</span><br><span class="line"><span class="comment">//上面创建结果等价于：</span></span><br><span class="line"><span class="keyword">var</span> My = &#123;</span><br><span class="line">    init:&#123;&#125;,</span><br><span class="line">    dom:&#123;</span><br><span class="line">        style:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用闭包封装私有变量</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __name = <span class="string">'anjie'</span>,</span><br><span class="line">        __age = <span class="number">25</span>,</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getUserInfo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> __name + <span class="string">'-'</span> + __age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="string">``</span><span class="string">`        </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">**我们使用下划线来约定私有变量__name和__age,他们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这样就避免了对全局的命令污染。**</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">###  通用单例模式     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">var</span> createDiv = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = $(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>);</span><br><span class="line">    div.html(<span class="string">'这个是测试div'</span>);</span><br><span class="line">    div.css(<span class="string">'display'</span>,<span class="string">'none'</span>);</span><br><span class="line">    $(<span class="string">'body'</span>).append(div);</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle(createDiv);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'loginBtn'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createSingleLoginLayer();</span><br><span class="line">    loginLayer.css(<span class="string">'display'</span>,<span class="string">'block'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>上面代码是一个通用的单例模式，我们在日常开发中可以直接利用这段代码来实现单例模式。</strong></p><hr><p><strong>以上代码借鉴于《JavaScript设计模式与开发实践》 – 曾探,这本书对设计模式进行的详细的介绍，推荐大家学习</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Javascript Function和函数学习笔记</title>
      <link href="/2017/08/16/function%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86/"/>
      <url>/2017/08/16/function%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>详细介绍javascript中函数的使用<br><a id="more"></a></p><h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>函数是由事件驱动的或者当它被调用执行的可复用的代码块</li></ul><p><code>js</code>支持两种函数：</p><ul><li>语言内部的函数（如<code>eval()</code>）</li><li>自己创建的函数</li></ul><p>在<code>js</code>函数内部声明的变量(使用<code>var</code>)是局部变量，只能在函数内部访问它<br>你可以在不同的函数声明相同的变量名称，因为它们是局部变量，两个不会相互影响</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>四种调用方式：</p><ul><li>作为函数</li><li>作为方法</li><li>作为构造函数</li><li>通过<code>call()</code>和<code>apply()</code></li></ul><h3 id="返回函数的函数"><a href="#返回函数的函数" class="headerlink" title="返回函数的函数"></a>返回函数的函数</h3><ol><li>当函数无明确返回值时，返回<code>undefined</code></li><li>当函数结束有<code>return</code>,返回什么就是什么</li></ol><p>我们可以利用<code>return</code>语句实现将函数返回值，或者单纯的结束函数<br>在使用了<code>return</code>的时候，函数会立即停止执行，如果<code>return</code>了值出去，函数的值就为返回的值</p><p><strong><em>函数通常会返回一个唯一值，这个值可能是另一个函数</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c = a +ｂ；</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());<span class="comment">//输出30；</span></span><br><span class="line"><span class="comment">//我们可以返回的函数赋值给你个变量</span></span><br><span class="line"><span class="keyword">var</span> fn1 = fn();</span><br><span class="line"><span class="built_in">console</span>.log(fn1);<span class="comment">//输出30；</span></span><br><span class="line"><span class="comment">//如果我们想返回的函数立即执行我们可以这样</span></span><br><span class="line"><span class="keyword">var</span> fn2 = fn()();<span class="comment">//在加一个括号表示立即执行函数</span></span><br></pre></td></tr></table></figure><p><code>js</code>函数传递参数都是按照值传递。</p><p><font color="red">引用类型</font>：</p><p><code>js</code>中引用类型都是存储在堆内存中的对象，变量中保存的实际只是一个指针，这个指针执行内存中的另一个位置，这个位置保存对象。</p><h3 id="创建匿名函数"><a href="#创建匿名函数" class="headerlink" title="创建匿名函数"></a>创建匿名函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我是一个没有名字的函数'</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>这种函数的好处是在我们只使用一次，省的在去定义一个函数名，避免命名冲突，<code>js</code>中没有命名空间的概念，因此有两个相同的函数名字，<code>js</code>会执行后面那个函数，因为<code>js</code>解析代码是一段一段的执行，他会按照最后出现的执行</p><ul><li>通过自我执行来执行匿名函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'打开程序我马上就执行啦！！！'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li>把匿名函数自我执行的返回值赋值给变量：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hi'</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">//输出hi</span></span><br></pre></td></tr></table></figure><ul><li>自我执行匿名函数的传参：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//输出10</span></span><br><span class="line">&#125;)(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="js创建动态函数"><a href="#js创建动态函数" class="headerlink" title="js创建动态函数"></a><code>js</code>创建动态函数</h3><p><code>js</code>支持创建动态函数，动态函数必须用<code>Function</code>对象来定义(Function是<code>js</code>中的一个对象，他是引用类型，是固定不变的，对象中的Function中的’F’必须大小）</p><p>创建动态函数的基本格式：<code>var 变量名 = new Function(&#39;参数1&#39;,&#39;参数2&#39;，&#39;参数n&#39;,&#39;执行语句&#39;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'var sum ; sum = x + y ; return sum;'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//输出5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的代码等同于：</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum;</span><br><span class="line">sum = x + y;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//输出5</span></span><br><span class="line"><span class="comment">//第一个函数是动态函数，第二个函数是静态函数</span></span><br></pre></td></tr></table></figure><p><strong><em>一般情况下我们不使用动态函数</em></strong></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数是一个函数的调用的过程，简单理解就是一个函数里面传参数，传的参数是一个函数，第一个函数执行完成后再去执行第二个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">fn1</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aa'</span>)；</span><br><span class="line">fn1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bb'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(fn1);</span><br><span class="line"><span class="comment">//先执行fn函数，fn函数执行完成后再执行fn1函数</span></span><br><span class="line"><span class="comment">//这里fn1函数就是回调函数</span></span><br></pre></td></tr></table></figure><h3 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">12</span>;   <span class="comment">// 变量：自由的</span></span><br><span class="line">arr.a= <span class="number">5</span>;     <span class="comment">//属性：属于一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)     //函数：自由的</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">alert(‘a’);</span><br><span class="line">&#125;</span><br><span class="line">arr.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)   //方法：属于一个对象</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">alert(‘b’);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>其实方法就是函数，只不过方法是所属的对象</em></strong></p><h3 id="JS全局函数"><a href="#JS全局函数" class="headerlink" title="JS全局函数"></a><code>JS</code>全局函数</h3><p>js中有7中全局函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>( )、<span class="built_in">eval</span>( )、<span class="built_in">isFinite</span>( )、<span class="built_in">isNaN</span>( )、<span class="built_in">parseFloat</span>( )、<span class="built_in">parseInt</span>( )、<span class="built_in">unescape</span>( )</span><br></pre></td></tr></table></figure><h3 id="函数的几个作用"><a href="#函数的几个作用" class="headerlink" title="函数的几个作用"></a>函数的几个作用</h3><ul><li>作为一个类构造器使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Class.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> item = <span class="keyword">new</span> Class();</span><br></pre></td></tr></table></figure><ul><li>作为闭包使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//独立的作用域</span></span><br><span class="line">&#125;)（）</span><br></pre></td></tr></table></figure><ul><li>作为构造函数调用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per1 = <span class="keyword">new</span> Person(<span class="string">'xiaoming'</span>,<span class="number">19</span>);</span><br><span class="line"><span class="keyword">var</span> per2 = <span class="keyword">new</span> Person(<span class="string">'xiaohong'</span>,<span class="number">20</span>);</span><br><span class="line">per1.name;<span class="comment">//输出'xiaoming'</span></span><br><span class="line">per1.age;<span class="comment">//输出19</span></span><br><span class="line">per2.name;<span class="comment">//输出'xiaohong'</span></span><br><span class="line">per2.age;<span class="comment">//输出20</span></span><br></pre></td></tr></table></figure><p>可以使用 new 运算符结合像 Object()、Date() 和 Function() 这样的预定义的构造函数来创建对象并对其初始化。面向对象的编程其强有力的特征是定义自定义构造函数以创建脚本中使用的自定义对象的能力。创建了自定义的构造函数，这样就可以创建具有已定义属性的对象。</p><p><strong><em>优缺点：</em></strong><br>使用构造器函数的优点是，它可以根据参数来构造不同的对象。 缺点是构造时每个实例对象都会生成重复调用对象的方法，造成了内存的浪费</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><ul><li><code>JS</code>中函数是一种语法，也是一个值，我们可以把函数赋值给一个变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFn = fn();</span><br><span class="line">fn(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//输出6</span></span><br><span class="line">newFn(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//输出12</span></span><br></pre></td></tr></table></figure><ul><li>函数也可以赋值给一个对象的属性，我们称为方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">//我们这里定义了一个空对象obj</span></span><br><span class="line">obj.seque = fn(<span class="number">2.3</span>);<span class="comment">//我们给空对象obj动态赋值了一个属性为seque</span></span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>这里的高阶函数可不是高数里的那个高阶函数，所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回新函数</p><h3 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h3><p>call()函数里面第一个参数是执行上下文，第二个是传递的参数。。。可以传递多个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">call</span>(<span class="params">this,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span>);</span></span><br></pre></td></tr></table></figure><p>apply()函数里面第一个参数是执行上下文，第二个是一个数组对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">apply</span>(<span class="params">this,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span>);</span></span><br></pre></td></tr></table></figure><p><strong><em>这部分后面还要完善，这里只是简单的介绍一下 add 2016.8.12</em></strong></p><h3 id="函数里面的参数-arguments"><a href="#函数里面的参数-arguments" class="headerlink" title="函数里面的参数(arguments)"></a>函数里面的参数(arguments)</h3><p>当函数被调用的时候，会得到一个参数数组，那就是<code>arguments</code>数组，通过它，函数可以访问所有它被调用时传递给它的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> i ,sum =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">sum+=<span class="built_in">arguments</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">4</span>,<span class="number">5</span>,<span class="number">23</span>,<span class="number">13</span>,<span class="number">35</span>,<span class="number">46</span>,<span class="number">-10</span>));<span class="comment">//116</span></span><br></pre></td></tr></table></figure><p><strong>实际上，arguments并不是一个真正的数组，它只是一个类数组的对象，它拥有一个length属性，但他缺少所有数组的方法。另外，arguments对象的长度是由传入的参数个数决定的，而不是由定义函数时的命名参数的个数决定的</strong></p><p><strong>函数在定义或者声明的时候，所有的参数都是形参，因此，我们可以根据实际情况来命名参数，函数也只有在被调用时才会传入实参。而每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments</strong></p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>函数的递归，即一个函数在通过名字调用自身的情况下构成的</p><h3 id="私有变量和私有函数"><a href="#私有变量和私有函数" class="headerlink" title="私有变量和私有函数"></a>私有变量和私有函数</h3><ul><li>定义在函数内部的变量和函数，如果不对外提供接口，外面是访问不到这些函数和变量的，这就叫做私有变量和私有函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;<span class="comment">//私有变量</span></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//私有函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFn = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(newFn.a);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(newFn.fn1);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="静态变量和函数"><a href="#静态变量和函数" class="headerlink" title="静态变量和函数"></a>静态变量和函数</h3><ul><li>当定义一个函数后通过点号 “.”为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Obj.num = <span class="number">72</span>;<span class="comment">//静态变量</span></span><br><span class="line">Obj.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//静态函数 </span></span><br><span class="line"></span><br><span class="line">alert(Obj.num);<span class="comment">//72</span></span><br><span class="line">alert(<span class="keyword">typeof</span> Obj.fn)<span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Obj();</span><br><span class="line">alert(t.name);<span class="comment">//undefined</span></span><br><span class="line">alert(<span class="keyword">typeof</span> t.fn);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="实例变量和函数"><a href="#实例变量和函数" class="headerlink" title="实例变量和函数"></a>实例变量和函数</h3><ul><li>在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，js也能做到这样</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a=[]; <span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">this</span>.fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Box.a); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Box.fn); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box=<span class="keyword">new</span> Box();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box.a); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box.fn); <span class="comment">//function</span></span><br></pre></td></tr></table></figure><p>为实例变量和方法添加新的方法和属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a=[]; <span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">this</span>.fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box1=<span class="keyword">new</span> Box();</span><br><span class="line">box1.a.push(<span class="number">1</span>);</span><br><span class="line">box1.fn=&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(box1.a); <span class="comment">//[1]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box1.fn); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box2=<span class="keyword">new</span> Box();</span><br><span class="line"><span class="built_in">console</span>.log(box2.a); <span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box2.fn); <span class="comment">//function</span></span><br></pre></td></tr></table></figure><p><strong>在box1中修改了a和fn，而在box2中没有改变，由于数组和函数都是对象，是引用类型，这就说明box1中的属性和方法与box2中的属性与方法虽然同名但却不是一个引用，而是对Box对象定义的属性和方法的一个复制。</strong></p><p><strong>这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢，prototype应运而生。</strong></p><h3 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h3><p><strong>基本概念：</strong></p><p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。</p><p>使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。</p><p>在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为原型链</p>]]></content>
      
      
      <categories>
          
          <category> javascript函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
