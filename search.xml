<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>TypeScript入门教程(一) - 基础类型</title>
      <link href="/2018/10/04/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%80)%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/04/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%80)%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><code>Typescript</code>中的基础类型和<code>JavaScript</code>中定义的五种基本类型(<code>Number</code>,<code>String</code>,<code>Boolean</code>,<code>Undefined</code>,<code>Null</code>)几乎相同,还新增了枚举类型,接下来我们详细介绍<code>TypeScript</code>中的基础类型<br><a id="more"></a></p><h3 id="布尔值-Boolean"><a href="#布尔值-Boolean" class="headerlink" title="布尔值(Boolean)"></a>布尔值(Boolean)</h3><ul><li>布尔值类型就是简单的<code>true</code> or <code>false</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isShow: <span class="built_in">boolean</span> = <span class="literal">true</span> </span><br><span class="line"><span class="comment">// :后面是指定变量isShow的类型，如果修改了isShow的变量类型为非boolean值就会报错</span></span><br></pre></td></tr></table></figure><h3 id="数字-Number"><a href="#数字-Number" class="headerlink" title="数字(Number)"></a>数字(Number)</h3><ul><li><code>Typescript</code>中的数字类型和<code>Javascript</code>中的数字类型一样都是浮点数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">26</span></span><br><span class="line"><span class="keyword">let</span> money: <span class="built_in">number</span> = <span class="number">6000.04</span></span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span></span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span></span><br></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li><code>Typescript</code>中的字符串和<code>JavaScript</code>字符串写法一样都是通过双引号(<code>&quot;&quot;</code>)或者单引号(<code>&#39;&#39;</code>)表示字符串</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1: <span class="built_in">string</span> = <span class="string">'hi'</span></span><br><span class="line"><span class="keyword">let</span> str2: <span class="built_in">string</span> = <span class="string">"hi"</span></span><br></pre></td></tr></table></figure><h3 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h3><ul><li><code>Typescript</code>中<code>null</code>和<code>undefined</code>两个各自有自己的类型分别是<code>null</code>和<code>undefined</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// undefined和null是所有类型的子集，就是你可以把所有类型赋值成undefined和null</span></span><br></pre></td></tr></table></figure><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><ul><li><code>Typescript</code>里面的数组和JavaScript中一样都可以操作数组元素,在<code>Typescript</code>中有两种定义数组的方式</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一:</span></span><br><span class="line"><span class="keyword">let</span> list1: <span class="built_in">string</span>[] = [<span class="string">'name1'</span>, <span class="string">'name2'</span>, <span class="string">'name3'</span>]</span><br><span class="line"><span class="keyword">let</span> list2: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 方法二:</span></span><br><span class="line"><span class="keyword">let</span> list3: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'name1'</span>, <span class="string">'name2'</span>, <span class="string">'name3'</span>]</span><br><span class="line"><span class="keyword">let</span> list4: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h3><ul><li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">t = [<span class="string">'mickey'</span>, <span class="number">26</span>] <span class="comment">// ok</span></span><br><span class="line">t = [<span class="number">26</span>, <span class="string">'mickey'</span>] <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举(Enum)"></a>枚举(Enum)</h3><ul><li><code>enum</code>类型是在<code>JavaScript</code>类型中新增的类型, 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Style &#123;width, height, color&#125;</span><br><span class="line"><span class="keyword">let</span> warp: Style = Style.width</span><br></pre></td></tr></table></figure><p>默认情况下，枚举里面的值是从<code>0</code>开始为元素编号，也可以手动的指定成员的数值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Style &#123;width = <span class="number">1</span>, height = <span class="number">2</span>, color = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> wrap: Style = Style.width</span><br><span class="line"><span class="comment">// 也可以通过枚举的值得到它的名字</span></span><br><span class="line"><span class="keyword">let</span> wrap: Style = Style[<span class="number">2</span>] <span class="comment">// height</span></span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><ul><li>我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查就可以使用<code>any</code>类型来标记这些变量</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="string">'mickey'</span></span><br><span class="line">a = <span class="number">26</span></span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list1: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="number">1</span>,<span class="string">'name1'</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p><strong><em>通过any定义的变量在后面可以随意赋值成其他类型的变量,这个就和js使用一样，js是弱类型语言定义变量可以不指定类型而且可以随意修改变量类型</em></strong></p><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><ul><li>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test...'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量为void 你只能为它赋值为 undefined和null</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">void</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><ul><li>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时</li><li>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的基础类型，第二节我们将介绍变量声明</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js原型继承五条基本原则</title>
      <link href="/2017/08/23/js%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BA%94%E6%9D%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
      <url>/2017/08/23/js%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BA%94%E6%9D%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>js中的原型继承，遵守5个基本原则：</p><ul><li>所有的数据都是对象</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li></ul><p>接下来我们将详细讲解这个5个基本原则…..</p><a id="more"></a><h3 id="所有的数据都是对象"><a href="#所有的数据都是对象" class="headerlink" title="所有的数据都是对象"></a>所有的数据都是对象</h3><p>js在设计的时候引入了java两套类型机制：<strong>基本类型</strong>和<strong>引用类型</strong></p><p>基本类型包括：<code>undefined、number、boolean、string、function、object</code></p><p>我们不能说js中所有的数据都是对象，但是可以说绝大多数的数据都是对象，那么相信在js中也一定会存在一个根对象(<strong>Object.prototype</strong>)</p><p>在js中根对象(<strong>Object.prototype</strong>)是一个空的对象，我们遇到的每一个对象都是从<strong>Object.prototype</strong>对象克隆而来，<strong>Object.prototype</strong>对象就是它们的原型。</p><pre><code>var obj_1 = new Object();var obj_2 = {};//通过Object.getPrototypeOf来查看它们的原型console.log(Object.getPrototypeOf(obj_1) === Object.prototype); // trueconsole.log(Object.getPrototypeOf(obj_2) === Object.prototype); // true    </code></pre><h3 id="要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"><a href="#要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它" class="headerlink" title="要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"></a>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</h3><p>在js中我们并不需要关心克隆的细节，因为这些操作浏览器引擎内部已经实现了，我们只需要显式地调用<code>var obj = new Object()或者var obj = {}</code>，引擎会从<code>Object.prototype</code>上克隆一个对象出来。</p><p>我们也可以通过new操作符来创建一个对象</p><pre><code>function Person(name){    this.name= name;};Person.prototype.getName = function(){    return this.name;}var r = new Person(&apos;anjie&apos;); // 通过new操作符得到一个对象console.log(r.name);//anjieconsole.log(r.getName());//anjieconsole.log(Object.getPrototypeOf(r) === Person.prototype); // true</code></pre><p><strong>我们通过new得到的对象具体做了什么？</strong><br>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4<br>个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性；</li><li>返回新对象；</li></ol><p>new操作符具体做了3件事</p><pre><code>// 创建空对象var r = {}; //将这个空对象的__proto__成员指向了Person函数对象prototype成员对象r.__proto__ = Person.prototype  //将Person函数对象的this指针替换成r，然后再调用Person函数,给r添加属性和方法Person.call(r)</code></pre><p><strong>模仿new操作符</strong></p><pre><code>function Person(name){    this.name = name;}Person.prototype.getName = function(){    return this.name;}var simulationNew = function(){    var obj = new Object(); // 从Objecet.prototype克隆一个对象    var Constructor = [].shift.call(arguments); // 获取外部参数    obj.__proto__ = Constructor.prototype;//指向正确的原型    var newObj = Constructor.apply(obj,arguments); //借用外部传入的构造器给obj设置属性    return typeof newObj === &apos;object&apos; ? newObj : obj; //确保返回的永远是一个对象}var a = simulationNew(Person,&apos;anjie&apos;);console.log(a.name);//anjieconsole.log(a.getName());//anjieconsole.log(Object.getPrototypeOf(a) === Person.prototype); // true</code></pre><h3 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h3><p>js给对象提供了一个名为<code>__proto__</code>的隐藏属性，某个对象的<code>__proto__</code>属性默认会指向它的构造器的原型对象，即<code>{Constructor.prototype}</code>,在一些浏览器中，<code>__proto__</code>被公开出来了(Chrome/Firefox)</p><pre><code>var a = new Object();console.log(a.__proto__ === Object.prototype); //true</code></pre><p><code>__proto__</code>就是对象跟对象构造器的原型联系起来的桥梁，正因为对象通过<code>__proto__</code>来记住的构造器的原型，我们上面模拟new操作符需要手动的给obj对象设置正确的<code>__proto__</code>指向</p><h3 id="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"><a href="#如果对象无法响应某个请求，它会把这个请求委托给它自己的原型" class="headerlink" title="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"></a>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</h3><p>在js中，每个对象都是通过<code>Object.prototype</code>克隆出来的，如果是这样的话我们只能得到单一的继承关系，即每个对象都是继承自<code>Object.prototype</code>对象，这样的对象显然是非常受限的。</p><p>js对象最初都是由<code>Object.prototype</code>克隆而来，但是对象构造器的原型并不仅限于<code>Object.prototype</code>上，而是可以动态指向其他对象，这样一来，但对象a需要借用b对象的能力时，可以选择性的把对象a的原型指向对象b，从而达到继承的效果。</p><p><strong>下面的代码是我们常用的原型继承方式：</strong></p><pre><code>var obj = {name:&apos;anjie&apos;};var A = function(){}A.prototype = obj;var a = new A();console.log(a.name);//anjie</code></pre><p><strong>上面的代码引擎内部做了什么？</strong></p><ul><li>遍历对象a中的所有属性，但是没有name这个属性</li><li>查找name属性的这个请求委托对象a的构造器的原型，它被<code>a.__proto__</code>记录着并且指向<code>A.prototype</code>,而<code>A.prototype</code>被设置为对象obj</li><li>在对象obj中找到name属性，并返回它的值</li></ul><p><strong>当我们期望得到一个类继承自另一个类时</strong>我们通常会使用下面这段代码：</p><pre><code>var A = function(){};A.prototype = {    name:&apos;anjie&apos;}var B = function(){}B.prototype = new A();var b = new B();console.log(b.name);//anjie</code></pre><p><strong>上面的代码引擎内部做了什么？</strong></p><ul><li>遍历对象a中的所有属性，但是没有name这个属性</li><li>查找name属性的这个请求委托对象b的构造器的原型，它被<code>b.__proto__</code>记录着并且指向<code>B.prototype</code>,而<code>B.prototype</code>被设置为通过<code>new A()</code>创建出来的对象</li><li>在该对象中依然没有找到name属性，于是请求将继续委托给这个对象构造器的原型<code>A.prototype</code></li><li>在<code>A.prototype</code>中找到name属性，并返回它的值</li></ul><p>如果<code>A.prototype</code>中还没有知道name属性，请求会被传递给<code>A.prototype</code>的原型<code>Object.prototype</code>，如果没有name属性，会继续传递给<code>Object.prototype</code>的原型，<code>Object.prototype</code>的原型是<code>null</code>,所以会返回<code>undefined</code></p><p>ES6的中带来了新的<code>Class</code>语法，让js看起来更加想一门基于类的语言，其实背后还是通过原型机制来实现的。</p><pre><code>Class Person{    constructor(name){        this.name = name;    },    getName(){        return this.name    }}Class manPerson extends Person {    constructor(name){        super(name);    }}var a = new manPerson(&apos;anjie&apos;);console.log(a.getName());//anjie</code></pre><p>总结就写到这里了，本文简单介绍了js中原型继承的机制，希望通过学习的我们的学习总结笔记让大家也有收获，如果有什么不对的地方，望大家指点出来，我们共同学习。</p>]]></content>
      
      
      <categories>
          
          <category> js原型继承 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/08/22/hello-world/"/>
      <url>/2017/08/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> MickeyAj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式单例模式</title>
      <link href="/2017/08/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/08/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是一种常见的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等。在js开发中，单例模式的用途同样非常广泛……<br><a id="more"></a></p><h3 id="JavaScript-设计模式-单例模式"><a href="#JavaScript-设计模式-单例模式" class="headerlink" title="JavaScript 设计模式-单例模式"></a>JavaScript 设计模式-单例模式</h3><h3 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h3><ul><li>定义：<code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</code></li></ul><h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><ul><li>原理：<code>用一个变量来保存当前是否已经为某个类创建对象，如果创建了就直接返回该对象，反之就重新实例化</code></li><li><p>代码：</p><pre><code>var Fn = function(name){    this.name = name;}Fn.prototype.getName = function(){    console.log(this.name);}Fn.getInstance = (function(){    var instance = null;    return function(name){        if(!instance){            instance = new Fn(name);        }        return instance;    }})();var a = Fn.getInstance(&apos;xxx&apos;);var b = Fn.getInstance(&apos;ooo&apos;);console.log(a === b);//true</code></pre></li></ul><h3 id="透明的单例模式"><a href="#透明的单例模式" class="headerlink" title="透明的单例模式"></a>透明的单例模式</h3><p>我们创建一个CreateDiv单例类来负责在页面中创建唯一的div节点，实现一个<strong>‘透明’</strong>的单例类，用户从这个类中创建对象的时候，可以像使用任何普通类一样。</p><ul><li><p>代码</p><pre><code>var CreateDiv = (function(){    var instance;    var CreateDiv = function(html){        if(instance){            return instance;        }        this.html= html;        this.init();        return instance = this;    };    CreateDiv.prototype.init = function(){        var div = $(&apos;&lt;div&gt;&lt;/div&gt;&apos;);        div.html(this.html);        $(body).append(div);    }    return CreateDiv;})()var a = new CreateDiv(&apos;one&apos;);var b = new CreateDiv(&apos;two&apos;);console.log(a === b); //true</code></pre><p>  上面的代码实现了<strong>透明</strong>单例，但是也有它的缺点，上面我们使用了自执行函数和闭包，并且让这个匿名函数返回真正的构造函数，这样增加了一些程序的复杂度。<br>  如果某天我们需要利用这个类，在页面上创建很多个div，既要让这个单例类变成一个普通的可以产生多个实例，那我们就需要修改CreateDiv构造函数，把控制创建唯一对象的那段代码删除掉，这样就会刚给我带来一些不必要的麻烦，所有我们利用另外一种方式去实现，这种方式叫着<strong>代理模式</strong>,后面的笔记中我会详细介绍<strong>代理模式</strong>的具体实习方式</p></li></ul><h3 id="利用代理模式实现单例模式"><a href="#利用代理模式实现单例模式" class="headerlink" title="利用代理模式实现单例模式"></a>利用代理模式实现单例模式</h3><p>我们把上面的透明单例代码中间创建div部分代码移除出去，使他成为一个普通的创建DIV类</p><ul><li><p>代码</p><pre><code>//创建div类var CreateDiv = function(html){    this.html = html;    this.init();}CreateDiv.prototype = function(){    var div = $(&apos;&lt;div&gt;&lt;/div&gt;&apos;);    div.html(this.html);    $(&apos;body&apos;).append(div);}//代理类var ProxySingleton = (function(){    var instance;    return function(){        if(!instance){            instance = new CreateDiv(html);        }        return instance;    }})()//测试var a = new ProxySingleton(&apos;one&apos;);var b = new ProxySingleton(&apos;two&apos;);console.log(a === b );//true</code></pre><p>  通过引入代理类的方式，我们也实现了单例模式，我们把负责管理单例的逻辑移到代理类<strong>ProxySingleton</strong>中，<strong>CreateDiv</strong>就变成一个普通类，它更<strong>ProxySingleton</strong>组合起来就可以实现单例模式的效果，这样的代码会更叫好维护。</p></li></ul><h3 id="JavaScript中的单例模式"><a href="#JavaScript中的单例模式" class="headerlink" title="JavaScript中的单例模式"></a>JavaScript中的单例模式</h3><ul><li>上面提到的创建单例模式，更多的是接近面向对象语言中的实现，单例对象从<strong>‘类’</strong>创建而来，在类为中心得语言中，这是很自然的做法。</li><li>在JavaScript中，其实是一门无类语言，没有类这个概念，在JS中创建单例模式方法很简单，我们只需要创建一个唯一的类。</li><li>全局变量不是单例模式，但是在js开发中，我们经常把全局变量当成单例模式来使用<h5 id="我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染"><a href="#我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染" class="headerlink" title="我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染"></a>我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染</h5></li></ul><ol><li><p>使用命名空间</p><h6 id="使用对象字面量的方式来创建："><a href="#使用对象字面量的方式来创建：" class="headerlink" title="使用对象字面量的方式来创建："></a>使用对象字面量的方式来创建：</h6><pre><code>var name = {    a:function(){        console.log(&apos;1&apos;);    },    b:function(){        console.log(&apos;2&apos;);    }};</code></pre><h6 id="使用动态创建命名空间"><a href="#使用动态创建命名空间" class="headerlink" title="使用动态创建命名空间"></a>使用动态创建命名空间</h6><pre><code>var My = {};My.name = function(name){    var parts = name.split(&apos;.&apos;);    var current = My;    for(var i in parts){        if(!current[parts[i]]){            current[parts[i]] = {};        }        current = current[parts[i]];    }}My.name = (&apos;init&apos;);My.name = (&apos;dom.style&apos;);//上面创建结果等价于：var My = {    init:{},    dom:{        style:{}    }};    </code></pre></li><li><p>使用闭包封装私有变量</p><pre><code>var user = (function(){    var __name = &apos;anjie&apos;,        __age = 25,    return {        getUserInfo:function(){            return __name + &apos;-&apos; + __age;        }    }    })();</code></pre><p><strong>我们使用下划线来约定私有变量<strong>name和</strong>age,他们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这样就避免了对全局的命令污染。</strong></p></li></ol><h3 id="通用单例模式"><a href="#通用单例模式" class="headerlink" title="通用单例模式"></a>通用单例模式</h3><p>直接上代码：</p><pre><code>var getSingle = function(fn){    var result;    return function(){        return result || (result = fn.apply(this,arguments));    }}//实例var createDiv = function(){    var div = $(&apos;&lt;div&gt;&lt;/div&gt;&apos;);    div.html(&apos;这个是测试div&apos;);    div.css(&apos;display&apos;,&apos;none&apos;);    $(&apos;body&apos;).append(div);    return div;}var createSingleLoginLayer = getSingle(createDiv);$(&apos;loginBtn&apos;).on(&apos;click&apos;,function(){    var loginLayer = createSingleLoginLayer();    loginLayer.css(&apos;display&apos;,&apos;block&apos;);})</code></pre><p><strong>上面代码是一个通用的单例模式，我们在日常开发中可以直接利用这段代码来实现单例模式。</strong></p><hr><p><strong>以上代码借鉴于《JavaScript设计模式与开发实践》 – 曾探,这本书对设计模式进行的详细的介绍，推荐大家学习</strong></p>]]></content>
      
      
      <categories>
          
          <category> js设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Javascript Function和函数学习笔记</title>
      <link href="/2017/08/16/function%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86/"/>
      <url>/2017/08/16/function%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>详细介绍javascript中函数的使用<br><a id="more"></a></p><h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念<hr></h3><ul><li>函数是由事件驱动的或者当它被调用执行的可复用的代码块</li></ul><p><code>js</code>支持两种函数：</p><ul><li>语言内部的函数（如<code>eval()</code>）</li><li>自己创建的函数</li></ul><p>在<code>js</code>函数内部声明的变量(使用<code>var</code>)是局部变量，只能在函数内部访问它<br>你可以在不同的函数声明相同的变量名称，因为它们是局部变量，两个不会相互影响</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用<hr></h3><p>四种调用方式：</p><ul><li>作为函数</li><li>作为方法</li><li>作为构造函数</li><li>通过<code>call()</code>和<code>apply()</code></li></ul><h3 id="返回函数的函数"><a href="#返回函数的函数" class="headerlink" title="返回函数的函数"></a>返回函数的函数<hr></h3><ol><li>当函数无明确返回值时，返回<code>undefined</code></li><li>当函数结束有<code>return</code>,返回什么就是什么</li></ol><p>我们可以利用<code>return</code>语句实现将函数返回值，或者单纯的结束函数<br>在使用了<code>return</code>的时候，函数会立即停止执行，如果<code>return</code>了值出去，函数的值就为返回的值</p><p><strong><em>函数通常会返回一个唯一值，这个值可能是另一个函数</em></strong></p><pre><code>function fn(){    var a = 10;    var b = 20;    var c = a +ｂ；    return c;}console.log(fn());//输出30；//我们可以返回的函数赋值给你个变量var fn1 = fn();console.log(fn1);//输出30；//如果我们想返回的函数立即执行我们可以这样var fn2 = fn()();//在加一个括号表示立即执行函数</code></pre><p><code>js</code>函数传递参数都是按照值传递。</p><p><font color="red">引用类型</font>：</p><p><code>js</code>中引用类型都是存储在堆内存中的对象，变量中保存的实际只是一个指针，这个指针执行内存中的另一个位置，这个位置保存对象。</p><h3 id="创建匿名函数"><a href="#创建匿名函数" class="headerlink" title="创建匿名函数"></a>创建匿名函数<hr></h3><pre><code>function(){    console.log(&apos;我是一个没有名字的函数&apos;)}()</code></pre><p>这种函数的好处是在我们只使用一次，省的在去定义一个函数名，避免命名冲突，<code>js</code>中没有命名空间的概念，因此有两个相同的函数名字，<code>js</code>会执行后面那个函数，因为<code>js</code>解析代码是一段一段的执行，他会按照最后出现的执行</p><ul><li><p>通过自我执行来执行匿名函数：</p><pre><code>(function(){    console.log(&apos;打开程序我马上就执行啦！！！&apos;)})()</code></pre></li><li><p>把匿名函数自我执行的返回值赋值给变量：</p><pre><code>var fn = (function(){    return &apos;hi&apos;;})();console.log(fn);//输出hi</code></pre></li><li><p>自我执行匿名函数的传参：</p><pre><code>(function(a){    console.log(a);//输出10})(10)</code></pre></li></ul><h3 id="js创建动态函数"><a href="#js创建动态函数" class="headerlink" title="js创建动态函数"></a><code>js</code>创建动态函数<hr></h3><p><code>js</code>支持创建动态函数，动态函数必须用<code>Function</code>对象来定义(Function是<code>js</code>中的一个对象，他是引用类型，是固定不变的，对象中的Function中的’F’必须大小）</p><p>创建动态函数的基本格式：<code>var 变量名 = new Function(&#39;参数1&#39;,&#39;参数2&#39;，&#39;参数n&#39;,&#39;执行语句&#39;)</code></p><pre><code>var fn = new Function(&apos;x&apos;,&apos;y&apos;,&apos;var sum ; sum = x + y ; return sum;&apos;)console.log(fn(2,3));//输出5//上面的代码等同于：var fn = function(x,y){    var sum;    sum = x + y;    return sum;}console.log(fn(2,3));//输出5//第一个函数是动态函数，第二个函数是静态函数</code></pre><p><strong><em>一般情况下我们不使用动态函数</em></strong></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数<hr></h3><p>回调函数是一个函数的调用的过程，简单理解就是一个函数里面传参数，传的参数是一个函数，第一个函数执行完成后再去执行第二个函数。</p><pre><code>function fn(fn1){    console.log(&apos;aa&apos;)；    fn1();}function fn1(){    console.log(&apos;bb&apos;);}fn(fn1);//先执行fn函数，fn函数执行完成后再执行fn1函数//这里fn1函数就是回调函数</code></pre><h3 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别<hr></h3><pre><code>var arr = [1,2,3,4,5]var a =12;   // 变量：自由的arr.a= 5;     //属性：属于一个对象function show()     //函数：自由的{     alert(‘a’);}arr.fn = function()   //方法：属于一个对象{     alert(‘b’);}</code></pre><p><strong><em>其实方法就是函数，只不过方法是所属的对象</em></strong></p><h3 id="JS全局函数"><a href="#JS全局函数" class="headerlink" title="JS全局函数"></a><code>JS</code>全局函数<hr></h3><p>js中有7中全局函数：</p><pre><code>escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( )</code></pre><h3 id="函数的几个作用"><a href="#函数的几个作用" class="headerlink" title="函数的几个作用"></a>函数的几个作用<hr></h3><ul><li><p>作为一个类构造器使用</p><pre><code>function Class(){};Class.prototype = {};var item = new Class();</code></pre></li><li><p>作为闭包使用</p><pre><code>(function(){    //独立的作用域})（）</code></pre></li><li><p>作为构造函数调用</p><pre><code>function Person(name,age){    this.name = name;    this.age = age;}var per1 = new Person(&apos;xiaoming&apos;,19);var per2 = new Person(&apos;xiaohong&apos;,20);per1.name;//输出&apos;xiaoming&apos;per1.age;//输出19per2.name;//输出&apos;xiaohong&apos;per2.age;//输出20</code></pre></li></ul><p>可以使用 new 运算符结合像 Object()、Date() 和 Function() 这样的预定义的构造函数来创建对象并对其初始化。面向对象的编程其强有力的特征是定义自定义构造函数以创建脚本中使用的自定义对象的能力。创建了自定义的构造函数，这样就可以创建具有已定义属性的对象。</p><p><strong><em>优缺点：</em></strong><br>使用构造器函数的优点是，它可以根据参数来构造不同的对象。 缺点是构造时每个实例对象都会生成重复调用对象的方法，造成了内存的浪费</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数<hr></h3><ul><li><p><code>JS</code>中函数是一种语法，也是一个值，我们可以把函数赋值给一个变量</p><p>  function fn(x,y){</p><pre><code>return x * y</code></pre><p>  }<br>  var newFn = fn();<br>  fn(2,3);//输出6<br>  newFn(3,4);//输出12</p></li><li><p>函数也可以赋值给一个对象的属性，我们称为方法</p><pre><code>function fn(x,y){    return x * y}var obj = {};//我们这里定义了一个空对象objobj.seque = fn(2.3);//我们给空对象obj动态赋值了一个属性为seque</code></pre></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数<hr></h3><p>这里的高阶函数可不是高数里的那个高阶函数，所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回新函数</p><h3 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()<hr></h3><p>call()函数里面第一个参数是执行上下文，第二个是传递的参数。。。可以传递多个参数</p><pre><code>function.call(this,1,2,3);</code></pre><p>apply()函数里面第一个参数是执行上下文，第二个是一个数组对象。</p><pre><code>function.apply(this,[1,2,3]);</code></pre><p><strong><em>这部分后面还要完善，这里只是简单的介绍一下 add 2016.8.12</em></strong></p><h3 id="函数里面的参数-arguments"><a href="#函数里面的参数-arguments" class="headerlink" title="函数里面的参数(arguments)"></a>函数里面的参数(arguments)<hr></h3><p>当函数被调用的时候，会得到一个参数数组，那就是<code>arguments</code>数组，通过它，函数可以访问所有它被调用时传递给它的参数</p><pre><code>var sum = function(){    var i ,sum =0;    for(i = 0;i&lt;arguments.length;i+=1){        sum+=arguments[i];    }    return sum;};   console.log(sum(4,5,23,13,35,46,-10));//116</code></pre><p><strong>实际上，arguments并不是一个真正的数组，它只是一个类数组的对象，它拥有一个length属性，但他缺少所有数组的方法。另外，arguments对象的长度是由传入的参数个数决定的，而不是由定义函数时的命名参数的个数决定的</strong></p><p><strong>函数在定义或者声明的时候，所有的参数都是形参，因此，我们可以根据实际情况来命名参数，函数也只有在被调用时才会传入实参。而每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments</strong></p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数<hr></h3><p>函数的递归，即一个函数在通过名字调用自身的情况下构成的</p><h3 id="私有变量和私有函数"><a href="#私有变量和私有函数" class="headerlink" title="私有变量和私有函数"></a>私有变量和私有函数<hr></h3><ul><li><p>定义在函数内部的变量和函数，如果不对外提供接口，外面是访问不到这些函数和变量的，这就叫做私有变量和私有函数</p><pre><code>function Fn(){    var a = 10;//私有变量    var fn1 = function(){};//私有函数}var newFn = new Fn();console.log(newFn.a);//undefinedconsole.log(newFn.fn1);//undefined</code></pre><h3 id="静态变量和函数"><a href="#静态变量和函数" class="headerlink" title="静态变量和函数"></a>静态变量和函数<hr></h3></li></ul><ul><li><p>当定义一个函数后通过点号 “.”为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。</p><pre><code>function Obj(){};Obj.num = 72;//静态变量Obj.fn = function(){}//静态函数 alert(Obj.num);//72alert(typeof Obj.fn)//functionvar t = new Obj();alert(t.name);//undefinedalert(typeof t.fn);//undefined</code></pre><h3 id="实例变量和函数"><a href="#实例变量和函数" class="headerlink" title="实例变量和函数"></a>实例变量和函数<hr></h3></li><li><p>在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，js也能做到这样</p><pre><code>function Box(){        this.a=[]; //实例变量        this.fn=function(){ //实例方法        }    }    console.log(typeof Box.a); //undefined    console.log(typeof Box.fn); //undefined    var box=new Box();    console.log(typeof box.a); //object    console.log(typeof box.fn); //function</code></pre></li></ul><p>为实例变量和方法添加新的方法和属性</p><pre><code>function Box(){            this.a=[]; //实例变量            this.fn=function(){ //实例方法            }        }        var box1=new Box();        box1.a.push(1);        box1.fn={};        console.log(box1.a); //[1]        console.log(typeof box1.fn); //object        var box2=new Box();        console.log(box2.a); //[]        console.log(typeof box2.fn); //function</code></pre><p><strong>在box1中修改了a和fn，而在box2中没有改变，由于数组和函数都是对象，是引用类型，这就说明box1中的属性和方法与box2中的属性与方法虽然同名但却不是一个引用，而是对Box对象定义的属性和方法的一个复制。</strong></p><p><strong>这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢，prototype应运而生。</strong></p><h3 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性<hr></h3><p><strong>基本概念：</strong></p><p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。</p><p>使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。</p><p>在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为原型链</p>]]></content>
      
      
      <categories>
          
          <category> javascript函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
