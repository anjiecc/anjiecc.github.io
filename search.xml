<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>vue源码解析,自己动手实现miniVue</title>
      <link href="/2018/12/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90,%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0miniVue/"/>
      <url>/2018/12/10/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90,%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0miniVue/</url>
      
        <content type="html"><![CDATA[<p>通过对<code>Vue</code>源码进行阅读,自己动手实现<code>miniVue</code>框架<br><a id="more"></a></p><h1 id="miniVue"><a href="#miniVue" class="headerlink" title="miniVue"></a>miniVue</h1><p>mini 版本 Vue,实现了 Vue 最核心部分代码,该项目是为了对 Vue 有更加深入了解,根据对源码剖析和自己的理解模拟 Vue 写的 mini 版本的 Vue</p><blockquote><p>目前没有实现diff算法,每次都是强制更新dom</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果使用MiniVue.min.js在实例化用new MiniVue.min进行实例化- --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果使用MiniVue.es5.js在实例化用new MiniVue.es5进行实例化- --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../dist/MiniVue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"aa"</span> <span class="attr">:class</span>=<span class="string">"classFn"</span> <span class="attr">style</span>=<span class="string">"font-size: 20px"</span> <span class="attr">:style</span>=<span class="string">"styleFn"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;a&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"a"</span> /&gt;</span> <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickFn"</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MiniVue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      a: <span class="number">1</span>,</span><br><span class="line">      color: <span class="string">'#999'</span>,</span><br><span class="line">      classFn: <span class="string">'bb'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    styleFn() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">color</span>: <span class="keyword">this</span>.color &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickFn() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'clickFn'</span>);</span><br><span class="line">      <span class="keyword">this</span>.a = <span class="keyword">this</span>.a === <span class="number">33333</span> ? <span class="number">2222</span> : <span class="number">33333</span>;</span><br><span class="line">      <span class="keyword">this</span>.color = <span class="keyword">this</span>.color === <span class="string">'red'</span> ? <span class="string">'#000'</span> : <span class="string">'red'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeMount'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeUpdate'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mounted'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.a = <span class="number">2222</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="./images/files.png" alt="目录结构"></p><p>Comilper—&gt;主要是处理<code>dom</code>编译</p><p>Instance—&gt;程序入口和创建<code>dom</code></p><p>Observer—&gt;数据拦截,数据订阅，发布，更新</p><p>Util—&gt;程序工具类(debug,nextTick…)</p><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><p>先看一张<code>Vue</code>官方文档中的图</p><p><img src="./images/1.png" alt="vue"></p><p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。</p><p>每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新</p><h3 id="MiniVue-响应式原理"><a href="#MiniVue-响应式原理" class="headerlink" title="MiniVue 响应式原理"></a>MiniVue 响应式原理</h3><p>MiniVue 是对 Vue 进行 深度学习得等的 产品,大部分代码都是来源<code>Vue</code>源码， 在<code>MiniVue</code>中使用了<code>Object.defineProperty()</code>进行数据劫持,来监听<code>setter</code>和<code>getter</code></p><ul><li>数据初始化劫持</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 初始化data对象数据,收集数据添加监听</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> _initData() &#123;</span><br><span class="line">   <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">let</span> data = <span class="keyword">this</span>.$options.data;</span><br><span class="line">   <span class="comment">// data支持两种写法(函数和对象)</span></span><br><span class="line">   <span class="comment">// 如果data是函数就直接执行拿到返回值,如果是对象直接返回</span></span><br><span class="line">   data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span> ? data.call(vm) : data || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">   <span class="keyword">let</span> i = keys.length;</span><br><span class="line">   <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">     <span class="keyword">let</span> key = keys[i];</span><br><span class="line">     <span class="keyword">this</span>.proxy(vm, <span class="string">'_data'</span>, key);</span><br><span class="line">   &#125;</span><br><span class="line">   observe(data, vm);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>核心代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  <span class="comment">// 可枚举</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      dep.depend();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">    <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新值</span></span><br><span class="line">    <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">      setter.call(obj, newVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的值是object的话，进行监听</span></span><br><span class="line">    childObj = observe(newVal);</span><br><span class="line">    <span class="comment">// 通知所有订阅者进行视图更新</span></span><br><span class="line">    dep.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们已经可以监听每个数据的变化了，那么监听到变化之后就通知订阅者，所以接下来我们需要实现一个消息订阅器，维护一个数组，用来收集订阅者，数据变动触发<code>notify</code>，再调用订阅者的<code>update</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅者Dep</span></span><br><span class="line"><span class="comment"> * 主要作用是用来存放Watcher观察者对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 标示id防止添加重复观察者对象</span></span><br><span class="line">    <span class="keyword">this</span>.id = uid++;</span><br><span class="line">    <span class="comment">// 存储观察者对象</span></span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加观察者</span></span><br><span class="line"><span class="comment">   * @param &#123;Watcher对象&#125; sub</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通知所有订阅者</span></span><br><span class="line"><span class="comment">   * update方法是挂载在Watcher原型对象上面的,方法内部会把需要的更新数据push到异步队列中,等到数据所有操作完成在进行视图更新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// 拷贝观察者对象</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="comment">// 循环所有观察者进行更新操作</span></span><br><span class="line">    subs.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.update();</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结: 响应式原理 —&gt; 初始化会获取<code>data</code>里面的数据，进行数据劫持使用<code>Object.defineProperty</code>进行数据劫持,对<code>data</code>里面的每一条数据进行<code>setter</code>和<code>getter</code>,当有获取数据触发<code>getter</code>进行依赖收集,当有数据发生改变触发<code>setter</code>更新数据,并且通知订阅者触发更新</p><h3 id="MiniVue-AST"><a href="#MiniVue-AST" class="headerlink" title="MiniVue AST"></a>MiniVue AST</h3><p>内部通过遍历 html 文档树，通过正则匹配转换成<code>AST</code>树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * html转为Ast</span></span><br><span class="line"><span class="comment">   * @returns Object AST语法树</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _convertHtml2Ast() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.template) &#123;</span><br><span class="line">      <span class="keyword">let</span> textEnd = <span class="keyword">this</span>.template.indexOf(<span class="string">'&lt;'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (textEnd === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是注释标签直接跳过编译</span></span><br><span class="line">        <span class="keyword">if</span> (regExp.comment.test(<span class="keyword">this</span>.template)) &#123;</span><br><span class="line">          <span class="keyword">let</span> commentEnd = <span class="keyword">this</span>.template.indexOf(<span class="string">'--&gt;'</span>);</span><br><span class="line">          <span class="keyword">this</span>._advance(commentEnd + <span class="number">3</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配结束标签</span></span><br><span class="line">        <span class="keyword">let</span> endTagMatch = <span class="keyword">this</span>.template.match(regExp.endTag);</span><br><span class="line">        <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">          <span class="keyword">let</span> _index = <span class="keyword">this</span>.index;</span><br><span class="line">          <span class="keyword">this</span>._advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">          <span class="keyword">this</span>._parseEndTag(endTagMatch[<span class="number">1</span>], _index, <span class="keyword">this</span>.index);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配开始标签</span></span><br><span class="line">        <span class="keyword">let</span> startTagMatch = <span class="keyword">this</span>._parseStartTag();</span><br><span class="line">        <span class="keyword">if</span> (startTagMatch) &#123;</span><br><span class="line">          <span class="keyword">this</span>._handleStartTag(startTagMatch);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = attrs.length; i &lt; l; i++) &#123;</span><br><span class="line">  map[attrs[i].name] = attrs[i].value;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1.匹配 @ 符号表示是绑定事件</span></span><br><span class="line"><span class="comment">   * 2.匹配 :class :style 表达式class和表达式style</span></span><br><span class="line"><span class="comment">   * 3.匹配 class style 静态class和静态style</span></span><br><span class="line"><span class="comment">   * 4.普通数据(如: id)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (attrs[i].name.match(<span class="regexp">/^@/g</span>)) &#123;</span><br><span class="line">    isEvent = <span class="literal">true</span>;</span><br><span class="line">    event[attrs[i].name.match(<span class="regexp">/\w*$/</span>)[<span class="number">0</span>]] = &#123; <span class="attr">value</span>: attrs[i].value &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class2styleReg.test(attrs[i].name)) &#123;</span><br><span class="line">    attrs[i].name.indexOf(<span class="string">'class'</span>) &gt; <span class="number">-1</span> ? (staticClass = attrs[i].value) : (staticStyle = attrs[i].value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (class2styleExpReg.test(attrs[i].name)) &#123;</span><br><span class="line">    attrs[i].name.indexOf(<span class="string">':class'</span>) &gt; <span class="number">-1</span> ? (classBinding = attrs[i].value) : (styleBinding = attrs[i].value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attrs[i].name === <span class="string">'v-model'</span>) &#123;</span><br><span class="line">    isEvent = <span class="literal">true</span>;</span><br><span class="line">    event[<span class="string">'input'</span>] = &#123; <span class="attr">value</span>: <span class="string">`function($event)&#123;if($event.target.composing)return;<span class="subst">$&#123;attrs[i].value&#125;</span>=$event.target.value&#125;`</span> &#125;;</span><br><span class="line"></span><br><span class="line">    props.push(&#123;</span><br><span class="line">      name: <span class="string">'value'</span>,</span><br><span class="line">      value: <span class="string">`(<span class="subst">$&#123;attrs[i].value&#125;</span>)`</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    directives.push(&#123;</span><br><span class="line">      arg: <span class="literal">null</span>,</span><br><span class="line">      modifiers: <span class="literal">undefined</span>,</span><br><span class="line">      name: <span class="string">'model'</span>,</span><br><span class="line">      rawName: <span class="string">'v-model'</span>,</span><br><span class="line">      value: attrs[i].value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _attrs.push(&#123;</span><br><span class="line">      name: attrs[i].name,</span><br><span class="line">      value: attrs[i].value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认根ast数据结构</span></span><br><span class="line"><span class="keyword">var</span> astMap = &#123;</span><br><span class="line">  type: <span class="number">1</span>,</span><br><span class="line">  tag: startTagMatch.tagName,</span><br><span class="line">  attrsList: attrs,</span><br><span class="line">  attrsMap: map,</span><br><span class="line">  parent: parent,</span><br><span class="line">  children: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过正则匹配把 Html 转为为 AST 树</p><p>结构如下:</p><p><img src="./images/2.png" alt="ast"></p><h3 id="MiniVue-VNode"><a href="#MiniVue-VNode" class="headerlink" title="MiniVue VNode"></a>MiniVue VNode</h3><p>VNode(虚拟Dom)<br>可以把真实 DOM 树抽象成一棵以 JavaScript 对象构成的抽象树，在修改抽象树数据后将抽象树转化成真实 DOM 重绘到页面上呢？于是虚拟 DOM 出现了，它是真实 DOM 的一层抽象，用属性描述真实 DOM 的各个特性。当它发生变化的时候，就会去修改视图。</p><p>可以想象，最简单粗暴的方法就是将整个 DOM 结构用 innerHTML 修改到页面上，但是这样进行重绘整个视图层是相当消耗性能的，我们是不是可以每次只更新它的修改呢？所以 Vue.js 将 DOM 抽象成一个以 JavaScript 对象为节点的虚拟 DOM 树，以 VNode 节点模拟真实 DOM，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，在这过程中都不需要操作真实 DOM，只需要操作 JavaScript 对象后只对差异修改，相对于整块的 innerHTML 的粗暴式修改，大大提升了性能。修改以后经过 diff 算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的 DOM 操作，大大提高了性能。</p><p>Vue 就使用了这样的抽象节点 VNode，它是对真实 DOM 的一层抽象，而不依赖某个平台，它可以是浏览器平台，也可以是 weex，甚至是 node 平台也可以对这样一棵抽象 DOM 树进行创建删除修改等操作，这也为前后端同构提供了可能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(tag, data, children, text, elm, context, componentOptions, asyncFactory) &#123;</span><br><span class="line">    <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    <span class="comment">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">    <span class="keyword">this</span>.children = children;</span><br><span class="line">    <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.elm = elm;</span><br><span class="line">    <span class="comment">/*当前节点的名字空间*/</span></span><br><span class="line">    <span class="keyword">this</span>.ns = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/*编译作用域*/</span></span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="comment">/*函数化组件作用域*/</span></span><br><span class="line">    <span class="keyword">this</span>.functionalContext = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/*节点的key属性，被当作节点的标志，用以优化*/</span></span><br><span class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key;</span><br><span class="line">    <span class="comment">/*组件的option选项*/</span></span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions;</span><br><span class="line">    <span class="comment">/*当前节点对应的组件的实例*/</span></span><br><span class="line">    <span class="keyword">this</span>.componentInstance = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/*当前节点的父节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*静态节点标志*/</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*是否作为跟节点插入*/</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*是否为注释节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*是否为克隆节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*是否有v-once指令*/</span></span><br><span class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  child() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会根据生成的<code>AST</code>树转换成 render 函数，render 函数创建每个节点 VNode</p><ul><li>render 函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"with(this)&#123;return _c('div',&#123;staticClass:"</span>aa bb<span class="string">",class:classFn,staticStyle:&#123;"</span>width<span class="string">":"</span><span class="number">200</span>px<span class="string">","</span>height<span class="string">":"</span><span class="number">50</span>px<span class="string">"&#125;,style:(styleFn),attrs:&#123;"</span>id<span class="string">":"</span>app<span class="string">"&#125;&#125;,[_c('input',&#123;directives:[&#123;name:"</span>model<span class="string">",rawName:"</span>v-model<span class="string">",value:(testData),expression:"</span>testData<span class="string">"&#125;],attrs:&#123;"</span>type<span class="string">":"</span>text<span class="string">","</span>name<span class="string">":"</span><span class="string">"&#125;,domProps:&#123;"</span>value<span class="string">":(testData)&#125;,on:&#123;"</span>input<span class="string">":function($event)&#123;if($event.target.composing)return;testData=$event.target.value&#125;&#125;&#125;),_v("</span> <span class="string">"),_c('button',&#123;on:&#123;"</span>click<span class="string">":update&#125;&#125;,[_v("</span>update<span class="string">")])])&#125;</span></span><br></pre></td></tr></table></figure><p>_c —&gt;创建标签</p><p>_v —&gt;创建文本节点</p><p>_s —&gt;字符串序列化</p><p>_c:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建元素</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; context miniVue实例</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; tag 标签</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; data 数据</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; children 子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">context, tag, data, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vnode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    createEmptyVNode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 兼容不传data的情况, 处理&lt;span&gt;&#123;&#123;a&#125;&#125;&lt;/span&gt;这种dom情况,字符串function为: _c('span', [_v(_s(a))])</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    children = data;</span><br><span class="line">    data = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    vnode = <span class="keyword">new</span> VNode(tag, data, children, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vnode !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_v:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建文本节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><img src="../../../../images/1.png" alt="vue"></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端大杂烩</title>
      <link href="/2018/11/29/%E5%89%8D%E7%AB%AF%08%08%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2018/11/29/%E5%89%8D%E7%AB%AF%08%08%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p>整理目前github上面比较优秀和热门的项目,文章，方便查看和学习<br><a id="more"></a></p><blockquote><p>提示 —&gt; 项目star数量是项目当前最新值,整理目的只是为了日后需要进行统一整理</p></blockquote><h3 id="2018-12-10更新"><a href="#2018-12-10更新" class="headerlink" title="2018-12-10更新"></a>2018-12-10更新</h3><p><a href="https://github.com/videojs/video.js?utm_source=gold_browser_extension" target="_blank" rel="noopener">video.js</a>  开源HTML5和Flash视频播放器 <iframe src="https://ghbtns.com/github-btn.html?user=videojs&repo=video.js&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><h3 id="2018-12-8更新"><a href="#2018-12-8更新" class="headerlink" title="2018-12-8更新"></a>2018-12-8更新</h3><p><a href="https://github.com/lovell/sharp?utm_source=gold_browser_extension" target="_blank" rel="noopener">sharp</a> 用于高效处理图像的node.js模块 <iframe src="https://ghbtns.com/github-btn.html?user=lovell&repo=sharp&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/mrdoob/three.js?utm_source=gold_browser_extension" target="_blank" rel="noopener">three.js</a> 一款javascript 3D库 <iframe src="https://ghbtns.com/github-btn.html?user=mrdoob&repo=three.js&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/MrRio/jsPDF?utm_source=gold_browser_extension" target="_blank" rel="noopener">jsPDF</a> jsPDF 客服端PDF生成工具 <iframe src="https://ghbtns.com/github-btn.html?user=MrRio&repo=jsPDF&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://mp.weixin.qq.com/s/esFqJnhbAYp1HN6-tIJZAw?" target="_blank" rel="noopener">前端构建：3 类 13 种热门工具的选型参考</a> 来自微信公众号</p><hr> <h3 id="2018-12-6更新"><a href="#2018-12-6更新" class="headerlink" title="2018-12-6更新"></a>2018-12-6更新</h3><p><a href="https://github.com/justjavac/free-programming-books-zh_CN?utm_source=gold_browser_extension" target="_blank" rel="noopener">free-programming-books-zh_CN</a> 免费的计算机编程类中文书籍 <iframe src="https://ghbtns.com/github-btn.html?user=justjavac&repo=free-programming-books-zh_CN&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="noopener">Charles 从入门到精通</a> mac charles网络抓包软件教程 </p><p><a href="https://jkchao.github.io/typescript-book-chinese/" target="_blank" rel="noopener">深入理解 TypeScript</a> 一本中文TypeScript的教程书，原版(英文版本)<a href="https://github.com/basarat/typescript-book" target="_blank" rel="noopener">typescript-book</a> </p><p><a href="https://juejin.im/post/5bfcbab0518825741e7bd67f?utm_source=gold_browser_extension" target="_blank" rel="noopener">初探 Vue3.0 中的一大亮点——Proxy !</a> 掘金原创文章</p><hr><h3 id="2018-12-3更新"><a href="#2018-12-3更新" class="headerlink" title="2018-12-3更新"></a>2018-12-3更新</h3><p><a href="https://github.com/antonmedv/fx?utm_source=gold_browser_extension" target="_blank" rel="noopener">fx</a> ensorSpace是一套用于构建神经网络3D可视化应用的框架 <iframe src="https://ghbtns.com/github-btn.html?user=antonmedv&repo=fx&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/tensorspace-team/tensorspace" target="_blank" rel="noopener">tensorspace</a>命令行工具和终端JSON查看器 <iframe src="https://ghbtns.com/github-btn.html?user=tensorspace-team&repo=tensorspace&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/ianstormtaylor/slate?utm_source=gold_browser_extension" target="_blank" rel="noopener">slate</a>可定制富文本编辑器 <iframe src="https://ghbtns.com/github-btn.html?user=ianstormtaylor&repo=slate&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/atlassian/react-beautiful-dnd?utm_source=gold_browser_extension" target="_blank" rel="noopener">react-beautiful-dnd</a>react 可拖拽ui列表 <iframe src="https://ghbtns.com/github-btn.html?user=atlassian&repo=react-beautiful-dnd&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><h3 id="2018-12-1更新"><a href="#2018-12-1更新" class="headerlink" title="2018-12-1更新"></a>2018-12-1更新</h3><p><a href="https://github.com/NorthwoodsSoftware/GoJS?utm_source=gold_browser_extension" target="_blank" rel="noopener">GoJS</a> 用于交互式流程图，组织结构图，设计工具，规划工具，可视语言的JavaScript图表库 <iframe src="https://ghbtns.com/github-btn.html?user=NorthwoodsSoftware&repo=GoJS&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://juejin.im/post/5c010de86fb9a049b41c3285" target="_blank" rel="noopener">TS 版 Promise 详解</a> 掘金原创文章</p><p><a href="https://juejin.im/post/5c00e0736fb9a049ca3713d7" target="_blank" rel="noopener">小程序云开发教程</a> 掘金原创文章</p><p><a href="https://juejin.im/post/5c00f7fe51882516be2ee2fc" target="_blank" rel="noopener">JS函数节流和函数防抖</a> 掘金原创文章</p><p><a href="https://tuobaye.com/2018/11/27/%E7%BB%86%E8%A7%A3JavaScript-ES7-ES8-ES9-%E6%96%B0%E7%89%B9%E6%80%A7/" target="_blank" rel="noopener">细解JavaScript ES7 ES8 ES9 新特性</a> </p><hr><h3 id="2018-11-29更新"><a href="#2018-11-29更新" class="headerlink" title="2018-11-29更新"></a>2018-11-29更新</h3><p><a href="https://github.com/vuejs/vue?utm_source=gold_browser_extension" target="_blank" rel="noopener">Vue</a>  用于构建用户界面的渐进式框架 <iframe src="https://ghbtns.com/github-btn.html?user=vuejs&repo=vue&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/facebook/react?utm_source=gold_browser_extension" target="_blank" rel="noopener">React</a>  <code>Facebook</code>出品,用于构建用户界面的<code>JS</code>库 <iframe src="https://ghbtns.com/github-btn.html?user=facebook&repo=react&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/nodejs/node?utm_source=gold_browser_extension" target="_blank" rel="noopener">Node</a>  基于V8引擎的javascript runtime  <iframe src="https://ghbtns.com/github-btn.html?user=nodejs&repo=node&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/axios/axios?utm_source=gold_browser_extension" target="_blank" rel="noopener">axios</a> 利用Promise编写的HTTP客服端  <iframe src="https://ghbtns.com/github-btn.html?user=axios&repo=axios&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/GoogleChrome/puppeteer?utm_source=gold_browser_extension" target="_blank" rel="noopener">puppeteer</a> 谷歌维护<code>Node</code>库,它提供了一个高级API来控制DevTools协议上的Chrome或Chromium,可以用着前端自动化测试,爬虫等<iframe src="https://ghbtns.com/github-btn.html?user=GoogleChrome&repo=puppeteer&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/NervJS/taro?utm_source=gold_browser_extension" target="_blank" rel="noopener">NervJs/taro</a>  多端统一开发框架，支持用 <code>React</code>的开发方式编写一次代码，生成能运行在微信小程序/百度智能小程序/支付宝小程序、H5、React Native 等的应用<iframe src="https://ghbtns.com/github-btn.html?user=NervJS&repo=taro&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/Tencent/omi?utm_source=gold_browser_extension" target="_blank" rel="noopener">Omi</a> 腾讯出品，4kb JavaScript中的下一代Web框架（Web Components + JSX + Proxy + Store + Path Updating),易于MVVM <iframe src="https://ghbtns.com/github-btn.html?user=Tencent&repo=omi&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/knsv/mermaid?utm_source=gold_browser_extension" target="_blank" rel="noopener">Mermaid</a> 一个生成流程图的工具   <iframe src="https://ghbtns.com/github-btn.html?user=knsv&repo=mermaid&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/pcottle/learnGitBranching?utm_source=gold_browser_extension" target="_blank" rel="noopener">learnGitBranching</a> 在线学git命令的使用,一个交互式的git可视化来挑战和学习 <iframe src="https://ghbtns.com/github-btn.html?user=pcottle&repo=learnGitBranching&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/bvaughn/progress-estimator?utm_source=gold_browser_extension" target="_blank" rel="noopener">progress-estimator</a> 记录进度条并估算Promise完成所需的时间  <iframe src="https://ghbtns.com/github-btn.html?user=bvaughn&repo=progress-estimator&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/dominictarr/event-stream?utm_source=gold_browser_extension" target="_blank" rel="noopener">event-stream</a>  EventStream is like functional programming meets IO <iframe src="https://ghbtns.com/github-btn.html?user=dominictarr&repo=event-stream&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/30-seconds/30-seconds-of-code?utm_source=gold_browser_extension" target="_blank" rel="noopener">30-seconds-of-code</a>  精选的有用JavaScript代码段集合，您可以在30秒或更短的时间内理解这些代码段 <iframe src="https://ghbtns.com/github-btn.html?user=30-seconds&repo=30-seconds-of-code&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/codrops/ImageRevealHover?utm_source=gold_browser_extension" target="_blank" rel="noopener">ImageRevealHover</a>  一组链接悬停效果，以不同的创作方式显示缩略图 <iframe src="https://ghbtns.com/github-btn.html?user=codrops&repo=ImageRevealHover&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/developit/htm?utm_source=gold_browser_extension" target="_blank" rel="noopener">htm</a>  使用标准标记模板的JSX替代方案，具有编译器支持 <iframe src="https://ghbtns.com/github-btn.html?user=developit&repo=htm&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/airbnb/javascript?utm_source=gold_browser_extension" target="_blank" rel="noopener">airbnb/javascript</a>  javascript代码规范和es-lint相关配置 <iframe src="https://ghbtns.com/github-btn.html?user=airbnb&repo=javascript&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/airbnb/javascript?utm_source=gold_browser_extension" target="_blank" rel="noopener">document-library</a>  jsliang 的文档库. 里面包含了所有的前端文章，例如 vue、react,、angular、微信小程序、设计模式等…… <iframe src="https://ghbtns.com/github-btn.html?user=airbnb&repo=javascript&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">mpvue</a>  基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系<iframe src="https://ghbtns.com/github-btn.html?user=Meituan-Dianping&repo=mpvue&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;"></iframe></p><hr><p><a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">element-ui</a>  基于 Vue 2.0 桌面ui库<iframe src="https://ghbtns.com/github-btn.html?user=ElemeFE&repo=element&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/iview/iview" target="_blank" rel="noopener">iview</a>  基于 Vue 2.0 桌面ui库<iframe src="https://ghbtns.com/github-btn.html?user=iview&repo=iview&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p><a href="https://github.com/vuejs/awesome-vue#components--libraries" target="_blank" rel="noopener">awesome-vue</a>  基于<code>Vue</code>优秀插件集合<iframe src="https://ghbtns.com/github-btn.html?user=vuejs&repo=awesome-vue&type=star&count=true&size=large" style="width:160px;height:30px;border: 0;display: inline-block;vertical-align: -9px;"></iframe></p><hr><p>持续更新…</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端开中遇到的问题整理</title>
      <link href="/2018/11/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2018/11/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在日常开发中移动端遇到的问题进行一个整理，方便后面查看<br><a id="more"></a></p><ul><li>弹出遮罩滚动条事件穿透</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一:</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二:</span></span><br><span class="line">.scroll &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> scroll = (<span class="function"><span class="keyword">function</span> (<span class="params">className</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        afterOpen: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            scrollTop = <span class="built_in">document</span>.scrollingElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">            <span class="built_in">document</span>.body.classList.add(className);</span><br><span class="line">            <span class="built_in">document</span>.body.style.top = -scrollTop + <span class="string">'px'</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeClose: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.body.classList.remove(className);</span><br><span class="line">            <span class="built_in">document</span>.scrollingElement.scrollTop = scrollTop;</span><br><span class="line">            <span class="built_in">document</span>.body.scrollTop = scrollTop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(<span class="string">'scroll'</span>);</span><br></pre></td></tr></table></figure><ul><li>IOS滚动条卡顿问题</li></ul><p>以下代码可解决这种卡顿的问题：<code>-webkit-overflow-scrolling: touch;</code>，是因为这行代码启用了硬件加速特性，所以滑动很流畅</p><p>推荐一个插件<a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">iScroll</a></p><ul><li>微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(WeixinJSBridge) == <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"WeixinJSBridgeReady"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            WeixinJSBridge.invoke(<span class="string">'setFontSizeCallback'</span>, &#123; <span class="string">'fontSize'</span>:<span class="number">0</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">                alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        WeixinJSBridge.invoke(<span class="string">'setFontSizeCallback'</span>, &#123; <span class="string">'fontSize'</span>:<span class="number">0</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小</span></span><br><span class="line">body &#123; -webkit-text-size-adjust:<span class="number">100</span>%!important; &#125;</span><br><span class="line"><span class="comment">//最好的解决方案：最好使用rem或百分比布局</span></span><br><span class="line"></span><br><span class="line">作者：我是大师兄啊</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/220b56eb20e9</span></span><br><span class="line">來源：简书</span><br><span class="line">简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</span><br></pre></td></tr></table></figure><ul><li><p>屏幕旋转的事件和样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orientInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> orientChk = <span class="built_in">document</span>.documentElement.clientWidth &gt; <span class="built_in">document</span>.documentElement.clientHeight?<span class="string">'landscape'</span>:<span class="string">'portrait'</span>;</span><br><span class="line">    <span class="keyword">if</span>(orientChk ==<span class="string">'lapdscape'</span>)&#123;</span><br><span class="line">        <span class="comment">//这里是横屏下需要执行的事件</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//这里是竖屏下需要执行的事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">orientInit();</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'onorientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span>?<span class="string">'orientationchange'</span>:<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(orientInit, <span class="number">100</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"><span class="comment">//CSS处理</span></span><br><span class="line"><span class="comment">//竖屏时样式</span></span><br><span class="line">@media all and (orientation:portrait)&#123;   &#125;</span><br><span class="line"><span class="comment">//横屏时样式</span></span><br><span class="line">@media all and (orientation:landscape)&#123;   &#125;</span><br><span class="line"></span><br><span class="line">作者：我是大师兄啊</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/220b56eb20e9</span></span><br><span class="line">來源：简书</span><br><span class="line">简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</span><br></pre></td></tr></table></figure></li><li><p>audio元素和video元素在ios和andriod中无法自动播放</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"music/bg.mp3"</span> <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">controls</span>&gt;</span>你的浏览器还不支持哦<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"music/bg.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"music/bg.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">    优先播放音乐bg.ogg，不支持在播放bg.mp3</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JS绑定自动播放（操作window时，播放音乐）</span></span><br><span class="line">$(<span class="built_in">window</span>).one(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    music.play();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//微信下兼容处理</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"WeixinJSBridgeReady"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    music.play();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//小结</span></span><br><span class="line"><span class="comment">//1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常</span></span><br><span class="line"><span class="comment">//2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间</span></span><br><span class="line"></span><br><span class="line">作者：我是大师兄啊</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/220b56eb20e9</span></span><br><span class="line">來源：简书</span><br><span class="line">简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</span><br></pre></td></tr></table></figure><ul><li>重力感应事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运用HTML5的deviceMotion，调用重力感应事件</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.DeviceMotionEvent)&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'devicemotion'</span>, deviceMotionHandler, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> speed = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> x = y = z = lastX = lastY = lastZ = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deviceMotionHandler</span>(<span class="params">eventData</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> acceleration = event.accelerationIncludingGravity;</span><br><span class="line">    x = acceleration.x;</span><br><span class="line">    y = acceleration.y; </span><br><span class="line">    z = acceleration.z;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(x-lastX)&gt;speed || <span class="built_in">Math</span>.abs(y-lastY)&gt;speed || <span class="built_in">Math</span>.abs(z-lastZ)&gt;speed )&#123;</span><br><span class="line">        <span class="comment">//这里是摇动后要执行的方法 </span></span><br><span class="line">        yaoAfter();</span><br><span class="line">    &#125;</span><br><span class="line">    lastX = x;</span><br><span class="line">    lastY = y;</span><br><span class="line">    lastZ = z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yaoAfter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>开启硬件加速 </li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate3d</span>(0,0,0);</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translate3d</span>(0,0,0);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">translate3d</span>(0,0,0);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0,0,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消除transition闪屏</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.css</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">    <span class="attribute">-webkit-backface-visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">-webkit-perspective</span>: <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持续更新中…</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FromData Blob ArrayBuffer</title>
      <link href="/2018/11/01/FormData%20Blob%20ArrayBuffer/"/>
      <url>/2018/11/01/FormData%20Blob%20ArrayBuffer/</url>
      
        <content type="html"><![CDATA[<p>利用<code>FormData</code>对象,我们可以通过<code>JavaScript</code>用一些键值对来模拟一系列表单控件,我们还可以使用<code>XMLHttpRequest</code>的<code>send()</code>方法来异步的提交这个”表单”,<code>Blob</code>对象表示一个不可变、原始数据的类文件对象,<code>ArrayBuffer</code>对象用来表示通用的、固定长度的原始二进制数据缓冲区<br><a id="more"></a></p><h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><blockquote><p>XMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个”表单”.比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件</p></blockquote><p>上文是<a href="https://developer.mozilla.org" target="_blank" rel="noopener">MDN</a>官方解释,在实际开发中我们可以利用它来进行做上传文件操作,下面代码简单介绍了<code>FormData</code>如何使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr= <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">let</span> fromdata = <span class="keyword">new</span> FormData()</span><br><span class="line">formdata.append(<span class="string">"token"</span>, <span class="string">'ddddd-ddd-dd'</span>);</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"xxx.php"</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h4 id="api"><a href="#api" class="headerlink" title="api"></a>api</h4><p><strong>append() 给当前FormData对象添加一个键/值对</strong><br><code>void append(DOMString name, Blob value, optional DOMString filename)</code></p><ul><li>name: 字段名称</li><li>value: 字段值.可以是,或者一个字符串,如果全都不是,则该值会被自动转换成字符串</li><li>filename[可选] 指定文件的文件名,当value参数被指定为一个Blob对象或者一个File对象时,该文件名会被发送到服务器上,对于Blob对象来说,这个值默认为”blob”)</li></ul><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p><code>Blob</code>即二进制大数据对象,提供相应的接口,其他操作二进制的对象都是建立在<code>Blob</code>基础之上,并继承了该对象的属性和方法</p><ul><li>使用 Blob 创建一个指向类型化数组的URL<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> typedArray = GetTheTypedArraySomehow();</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([typedArray], &#123;<span class="attr">type</span>: <span class="string">"application/octet-binary"</span>&#125;);<span class="comment">// 传入一个合适的MIME类型</span></span><br><span class="line"><span class="keyword">var</span> url = URL.createObjectURL(blob);</span><br><span class="line"><span class="comment">// 会产生一个类似blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串</span></span><br><span class="line"><span class="comment">// 你可以像使用一个普通URL那样使用它，比如用在img.src上</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="api-1"><a href="#api-1" class="headerlink" title="api"></a>api</h4><ul><li><code>Blob.size</code>[只读]  <code>Blob</code>对象中所包含数据的大小（字节）</li><li><code>Blob.type</code>[只读]  一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型未知，则该值为空字符串</li><li><code>Blob.slice(start,end)</code> 返回一个新的 Blob对象，包含了源 Blob对象中指定范围内的数据</li></ul><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p><code>ArrayBuffer</code>对象用来表示通用的、固定长度的原始二进制数据缓冲区。<code>ArrayBuffer</code>不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个8字节的ArrayBuffer  </span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建一个指向b的视图v1，采用Int32类型，开始于默认的字节索引0，直到缓冲区的末尾  </span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建一个指向b的视图v2，采用Uint8类型，开始于字节索引2，直到缓冲区的末尾  </span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建一个指向b的视图v3，采用Int16类型，开始于字节索引2，长度为2  </span></span><br><span class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="api-2"><a href="#api-2" class="headerlink" title="api"></a>api</h4><ul><li><code>new ArrayBuffer(length)</code><br><code>length</code>要创建的 ArrayBuffer 的大小，单位为字节,返回一个指定大小的 ArrayBuffer 对象，其内容被初始化为 0</li></ul><ul><li><code>get ArrayBuffer[@@species]</code><br>返回 ArrayBuffer 的构造函数</li></ul><ul><li><p><code>ArrayBuffer.isView(arg)</code><br>如果参数是 ArrayBuffer 的视图实例则返回 true，例如 类型数组对象 或 DataView 对象；否则返回 false</p></li><li><p><code>ArrayBuffer.transfer(oldBuffer [, newByteLength])</code><br>返回一个新的 ArrayBuffer 对象，其内容取自 oldBuffer 中的数据，并且根据 newByteLength 的大小对数据进行截取或补 0</p></li></ul><ul><li><code>ArrayBuffer.slice()</code><br>返回一个新的 ArrayBuffer ，它的内容是这个 ArrayBuffer 的字节副本，从begin（包括），到end（不包括）。如果begin或end是负数，则指的是从数组末尾开始的索引，而不是从头开始</li></ul><blockquote><p>文章参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer-MDN</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">Blob-MDN</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="noopener">FormData-MDN</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS BEM书写规范</title>
      <link href="/2018/10/31/CSS%20BEM%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"/>
      <url>/2018/10/31/CSS%20BEM%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p><code>BEM</code>的意思就是块（<code>block</code>）、元素（<code>element</code>）、修饰符（<code>modifier</code>）,是由<a href="https://yandex.ru/" target="_blank" rel="noopener">Yandex</a>团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目<br><a id="more"></a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>如果你是一个<code>Vue</code>爱好者，并且你是一个喜欢接受新鲜事物和追求技术高度,那么你一定使用或者知道<a href="http://element.eleme.io/#/zh-CN" target="_blank" rel="noopener">Element-Ui</a>(或者其他UI库),在<code>element-ui</code>中你去观察它的源码你会发现它的组件<code>css</code>的定义方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">include</span> b(tree-node) &#123;</span><br><span class="line">  <span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br><span class="line">  <span class="selector-tag">outline</span>: <span class="selector-tag">none</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:focus</span> &#123; <span class="comment">/* focus */</span></span><br><span class="line">    &gt; .el-tree-node__content &#123;</span><br><span class="line">      background-color: $--tree-node-hover-color;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">include</span> when(drop-inner) &#123;</span><br><span class="line">    &gt; <span class="selector-class">.el-tree-node__content</span> <span class="selector-class">.el-tree-node__label</span> &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: $--color-primary;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是<code>element-ui</code>中组件<code>tree</code>组件的部分样式</p><p>不难从上面代码中可以看到<code>element-ui</code>是怎么来命名<code>class</code>类名和<code>sass</code>变量都使用了<code>-</code>,<code>__</code>,’–’这个连字符,下面我们介绍为什么要这样写,这样写的好处是什么</p><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p><code>BEM</code>代表“<code>块（block</code>）,<code>元素（element</code>）,<code>修饰符（modifier</code>”,我们常用这三个实体开发组件。</p><p>在选择器中，由以下三种符合来表示扩展的关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-  中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号</span><br><span class="line">__  双下划线：双下划线用来连接块和块的子元素</span><br><span class="line">_   单下划线：单下划线用来描述一个块或者块的子元素的一种状态</span><br><span class="line"></span><br><span class="line">type-block__element_modifier</span><br></pre></td></tr></table></figure><h4 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h4><p>一个块是设计或布局的一部分，它有具体且唯一地意义 ，要么是语义上的要么是视觉上的</p><p>例如我们有一个菜单列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类名<code>menu</code>就是代表菜单这个<code>块</code>或者<code>区域</code></p><h4 id="元素（element）"><a href="#元素（element）" class="headerlink" title="元素（element）"></a>元素（element）</h4><p>块中的子元素是块的子元素，并且子元素的子元素在 bem 里也被认为是块的直接子元素。一个块中元素的类名必须用父级块的名称作为前缀</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类名<code>menu__item</code>中的<code>__item</code>就是代表元素项</p><h4 id="修饰符（modifier）"><a href="#修饰符（modifier）" class="headerlink" title="修饰符（modifier）"></a>修饰符（modifier）</h4><p>一个“修饰符”可以理解为一个块的特定状态，标识着它持有一个特定的属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item menu__item-actived"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu__item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类名<code>menu__item-actived</code>中的<code>-actived</code>代表修饰符</p><h3 id="可供选择的命名方案"><a href="#可供选择的命名方案" class="headerlink" title="可供选择的命名方案"></a>可供选择的命名方案</h3><p><code>BEM</code>只是一种命名约定方案不一定要按照固定写法来执行,主要是在项目中要保持一致的命名约定即可</p><p>下面有几种方案提供参考</p><h4 id="Two-Dashes-style（双连字符风格）"><a href="#Two-Dashes-style（双连字符风格）" class="headerlink" title="Two Dashes style（双连字符风格）"></a>Two Dashes style（双连字符风格）</h4><p><code>block-name__elem-name--mod-name</code></p><ul><li>名字全部使用小写</li><li>BEM 实体的名称中的每一个单词使用一个连字符分隔</li><li>使用双下划线（__）将元素的名称和模块的名称分离开</li><li>使用双连字符（–）分隔 Boolean 类型的修饰符</li><li>不使用 key-value 类型的修饰符</li></ul><h4 id="CamelCase-style（驼峰命名风格）"><a href="#CamelCase-style（驼峰命名风格）" class="headerlink" title="CamelCase style（驼峰命名风格）"></a>CamelCase style（驼峰命名风格）</h4><p><code>MyBlock__SomeElem_modName_modVla</code></p><p>这种风格的命名方案的不同点在于，在<code>BEM</code>实体中分隔单词时使用驼峰命名法代替了一个连字符（<code>-</code>）</p><h4 id="“Sans-underscore”-style（无下划线风格）"><a href="#“Sans-underscore”-style（无下划线风格）" class="headerlink" title="“Sans underscore” style（无下划线风格）"></a>“Sans underscore” style（无下划线风格）</h4><p><code>blockName-elemName--modName--modVal</code></p><ul><li>名称使用驼峰命名法书写</li><li>元素名称与模块名称使用一个连字符（-）分隔</li><li>修饰符使用双连字符（–）与模块或元素分隔</li><li>修饰符的名称和值使用双连字符（–）分隔</li></ul><p><code>BEM</code>方法论为<code>BEM</code>实体的命名提供了基本的原则。选择哪一种命名方式取决于你项目的需求和你的个人喜好。使用方法论中提到的命名约定的一大优势在于具有现成的面向“经典命名”的开发工具</p><blockquote><p>文章参考<br><a href="https://www.jianshu.com/p/410a71771d78" target="_blank" rel="noopener">【译】BEM CSS命名规范三 Naming convention</a><br><a href="https://www.w3cschool.cn/weflow/weflow-bem.html" target="_blank" rel="noopener">W3cschool</a><br><a href="https://docs.emmet.io/filters/bem/" target="_blank" rel="noopener">Yandex BEM/OOCSS</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(十四) - 装饰器</title>
      <link href="/2018/10/22/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81%E5%9B%9B)%20-%20%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2018/10/22/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81%E5%9B%9B)%20-%20%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>随着<code>TypeScript</code>和<code>ES6</code>里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（<code>Decorators</code>）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 <code>Javascript</code>里的装饰器目前处在<code>建议征集的第二阶段</code>，但在<code>TypeScript</code>里已做为一项实验性特性予以支持</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>若要启用实验性的装饰器特性，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项</p><ul><li><p>命令行:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure></li><li><p>tsconfig.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">        <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用<code>@expression</code>这种形式，<code>expression</code>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件(·<br><code>.d.ts</code>)，重载或者任何外部上下文（比如<code>declare</code>的类）中</p><p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数</p><ul><li><p>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</p></li><li><p>成员的名字</p></li><li><p>成员的属性描述符</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    greeting: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@enumerable</span>(<span class="literal">false</span>)</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        descriptor.enumerable = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><p>访问器装饰器声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（<code>.d.ts</code>），或者任何外部上下文（比如<code>declare</code>的类）里</p><blockquote><p>TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的</p></blockquote><p>访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ul><li><p>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</p></li><li><p>成员的名字</p></li><li><p>成员的属性描述符</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    <span class="keyword">private</span> _x: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> _y: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._x = x;</span><br><span class="line">        <span class="keyword">this</span>._y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">get</span> x() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">get</span> y() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configurable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">        descriptor.configurable = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>属性装饰器声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（<code>.d.ts</code>），或者任何外部上下文（比如<code>declare</code>的类）里</p><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p><ul><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li><li>成员的名字</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    <span class="meta">@format</span>(<span class="string">"Hello, %s"</span>)</span><br><span class="line">    greeting: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">let</span> formatString = getFormat(<span class="keyword">this</span>, <span class="string">"greeting"</span>);</span><br><span class="line">        <span class="keyword">return</span> formatString.replace(<span class="string">"%s"</span>, <span class="keyword">this</span>.greeting);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formatMetadataKey = Symbol(<span class="string">"format"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">formatString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Reflect.metadata(formatMetadataKey, formatString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFormat</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Reflect.getMetadata(formatMetadataKey, target, propertyKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>@format(&quot;Hello, %s&quot;)</code>装饰器是个装饰器工厂。 当<code>@format(&quot;Hello, %s&quot;)</code>被调用时，它添加一条这个属性的元数据，通过<code>reflect-metadata</code>库里的<code>Reflect.metadata</code>函数。 当 <code>getFormat</code>被调用时，它读取格式的元数据</p><blockquote><p> 这个例子需要使用reflect-metadata库。 查看 元数据了解reflect-metadata库更详细的信息。</p></blockquote><h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（<code>.d.ts</code>），重载或其它外部上下文（比如<code>declare</code>的类）里</p><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ul><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li><li>成员的名字</li><li>参数在函数参数列表中的索引</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    greeting: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@validate</span></span><br><span class="line">    greet(<span class="meta">@required</span> name: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">", "</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requiredMetadataKey = Symbol(<span class="string">"required"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">required</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | symbol, parameterIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> existingRequiredParameters: <span class="built_in">number</span>[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];</span><br><span class="line">    existingRequiredParameters.push(parameterIndex);</span><br><span class="line">    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">target: <span class="built_in">any</span>, propertyName: <span class="built_in">string</span>, descriptor: TypedPropertyDescriptor&lt;<span class="built_in">Function</span>&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> method = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> requiredParameters: <span class="built_in">number</span>[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);</span><br><span class="line">        <span class="keyword">if</span> (requiredParameters) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> parameterIndex of requiredParameters) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameterIndex &gt;= <span class="built_in">arguments</span>.length || <span class="built_in">arguments</span>[parameterIndex] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Missing required argument."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@required</code>装饰器添加了元数据实体把参数标记为必需的。 <code>@validate</code>装饰器把<code>greet</code>方法包裹在一个函数里在调用原先的函数前验证函数参数</p><p>上面我们介绍了<code>TypeScript</code>的装饰器，到此<code>Typescript</code>入门教程完结</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(十三) - 命名空间</title>
      <link href="/2018/10/22/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81%E4%B8%89)%20-%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2018/10/22/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81%E4%B8%89)%20-%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>描述了如何在TypeScript里使用命名空间（之前叫做“内部模块”）来组织你的代码。任何使用<code>module</code>关键字来声明一个内部模块的地方都应该使用<code>namespace</code>关键字来替换<br><a id="more"></a></p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>使用命名空间不用担心与其它对象产生命名冲突</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line">    <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lettersRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">"Hello"</span>, <span class="string">"98052"</span>, <span class="string">"101"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator; &#125; = &#123;&#125;;</span><br><span class="line">validators[<span class="string">"ZIP code"</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator();</span><br><span class="line">validators[<span class="string">"Letters only"</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`"<span class="subst">$&#123; s &#125;</span>" - <span class="subst">$&#123; validators[name].isAcceptable(s) ? "matches" : "does not match" &#125;</span> <span class="subst">$&#123; name &#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>另一种简化命名空间操作的方法是使用import q = x.y.z给常用的对象起一个短的名字。 不要与用来加载模块的 import x = require(‘name’)语法弄混了，这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123; &#125;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> Square &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = Shapes.Polygons;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.Square(); <span class="comment">// Same as "new Shapes.Polygons.Square()"</span></span><br></pre></td></tr></table></figure><h3 id="外部命名空间"><a href="#外部命名空间" class="headerlink" title="外部命名空间"></a>外部命名空间</h3><p>流行的程序库D3在全局对象d3里定义它的功能。 因为这个库通过一个 <script>标签加载（不是通过模块加载器），它的声明文件使用内部模块来定义它的类型。 为了让TypeScript编译器识别它的类型，我们使用外部命名空间声明。 比如，我们可以像下面这样写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> D3 &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Selectors &#123;</span><br><span class="line">        select: &#123;</span><br><span class="line">            (selector: <span class="built_in">string</span>): Selection;</span><br><span class="line">            (element: EventTarget): Selection;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Event &#123;</span><br><span class="line">        x: <span class="built_in">number</span>;</span><br><span class="line">        y: <span class="built_in">number</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Base <span class="keyword">extends</span> Selectors &#123;</span><br><span class="line">        event: Event;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> d3: D3.Base;</span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的命名空间，第十四节我们将介绍装饰器</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html">TypeScript中文网</a></p></blockquote></script></p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(十二) - 模块</title>
      <link href="/2018/10/20/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81%E4%BA%8C)%20-%20%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/10/20/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81%E4%BA%8C)%20-%20%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>模块是在自身的作用域执行,也就是说在一个模块里面声明的变量,类,函数都是在模块中可见,模块外面是不可见的，除非使用<code>export</code>导出,其他模块使用<code>import</code>引入就可以使用其他模块导出的变量,类,函数等<br><a id="more"></a></p><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>任何声明(变量,函数,类,类别别名或接口)都能够通过添加<code>export</code>关键字来导出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="string">'112'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">string</span></span><br><span class="line">    height: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Fn &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;Fn <span class="keyword">as</span> fn&#125; <span class="comment">// 导出的部分重命名</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'文件路径'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Styles &#123;&#125; <span class="comment">// 默认导出</span></span><br></pre></td></tr></table></figure><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>模块的导入操作与导出一样简单。 可以使用以下 import形式之一来导入其它模块中的导出内容</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Fn &#125; <span class="keyword">from</span> <span class="string">'引入的文件路径'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Fn <span class="keyword">as</span> fn &#125; <span class="keyword">from</span> <span class="string">'引入的文件路径'</span> <span class="comment">// 导入内容重命名</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> styles <span class="keyword">from</span> <span class="string">'引入的文件路径'</span> <span class="comment">// 将整个模块导入到一个变量</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'引入的文件路径'</span> <span class="comment">// 引入文件</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'引入的文件路径'</span> <span class="comment">// 引入默认导出文件</span></span><br></pre></td></tr></table></figure><h3 id="export-和-import-require"><a href="#export-和-import-require" class="headerlink" title="export = 和 import = require()"></a>export = 和 import = require()</h3><p><code>CommonJS</code>和<code>AMD</code>的环境里都有一个<code>exports</code>变量，这个变量包含了一个模块的所有导出内容。</p><p><code>CommonJS</code>和<code>AMD</code>的<code>exports</code>都可以被赋值为一个对象, 这种情况下其作用就类似于<code>es6</code>语法里的默认导出，即<code>export default</code>语法了。虽然作用相似，但是<code>export default</code>语法并不能兼容<code>CommonJS</code>和<code>AMD</code>的exports。</p><p>为了支持<code>CommonJS</code>和<code>AMD</code>的<code>exports</code>, <code>TypeScript</code>提供了<code>export =</code>语法。</p><p><code>export =</code>语法定义一个模块的导出对象。 这里的对象一词指的是类，接口，命名空间，函数或枚举。</p><p>若使用<code>export =</code>导出一个模块，则必须使用<code>TypeScript</code>的特定语法<code>import module = require(&quot;module&quot;)</code>来导入此模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Styles &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> styles: object</span>)</span><br><span class="line">    getStyle(<span class="params">key: <span class="built_in">string</span></span>): number | string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.styles[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = Styles</span><br><span class="line"><span class="comment">// 使用方式如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Styles = <span class="built_in">require</span>(<span class="string">'文件路径'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Styles(&#123; width : <span class="number">200</span> &#125;)</span><br><span class="line">s.getStyle(<span class="string">'width'</span>) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的模块，第十三节我们将介绍命名空间</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(十一) - 迭代器和生成器</title>
      <link href="/2018/10/18/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81%E4%B8%80)%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2018/10/18/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81%E4%B8%80)%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>迭代器和生成器<br><a id="more"></a></p><h3 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for..of 语句"></a>for..of 语句</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray = [<span class="number">1</span>, <span class="string">"string"</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry of someArray) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry); <span class="comment">// 1, "string", false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for..in 语句"></a>for..in 语句</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// "0", "1", "2",</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i of list) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// "4", "5", "6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>for..of和for..in均可迭代一个列表；但是用于迭代的值却不同，for..in迭代的是对象的 键 的列表，而for..of则迭代对象的键对应的值，for..in可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值</p><p>这节的内容比较简单,所以只是写了几段代码来进行解释</p><p>上面我们介绍了<code>TypeScript</code>的迭代器和生成器，第十二节我们将介绍模块</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(十) - Symbols</title>
      <link href="/2018/10/18/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81)%20-%20Symbols/"/>
      <url>/2018/10/18/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%8D%81)%20-%20Symbols/</url>
      
        <content type="html"><![CDATA[<p>自ECMAScript 2015(ES6)起，symbol成为了一种新的原生类型，就像number和string一样<br><a id="more"></a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>symbol</code>类型的值是通过<code>Symbol</code>构造函数创建的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym2 = Symbol(<span class="string">"key"</span>); <span class="comment">// 可选的字符串key</span></span><br></pre></td></tr></table></figure><p>需要注意的是<code>symbol</code>是唯一的<br>像字符串一样，symbols也可以被用做对象属性的键,也可以计算出的属性名声明相结合来声明对象的属性和类成员</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [sym]: <span class="string">"value"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]); <span class="comment">// "value"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getClassNameSymbol = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">    [getClassNameSymbol]()&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> className = c[getClassNameSymbol](); <span class="comment">// "C"</span></span><br></pre></td></tr></table></figure><p>更多<code>Symbols</code>用法建议查看<a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">阮一峰ES6</a>里面写的很详细</p><p>上面我们介绍了<code>TypeScript</code>的Symbols，第十一节我们将介绍迭代器和生成器</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(九) - 高级类型</title>
      <link href="/2018/10/17/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B9%9D)%20-%20%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/17/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B9%9D)%20-%20%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>高级类型(交叉类型,联合类型,类型保护与区分类型,类型别名,字符串字面量类型,数字字面量类型,枚举成员类型,多态的this类型,索引类型,映射类型)我们会对10种进行详情介绍<br><a id="more"></a></p><h3 id="交叉类型-Intersection-Types"><a href="#交叉类型-Intersection-Types" class="headerlink" title="交叉类型(Intersection Types)"></a>交叉类型(Intersection Types)</h3><p>交叉类型是将多个类型合并到一个类型,比如:<code>Fn1 &amp; Fn2 &amp; Fn3</code>同时是<code>Fn1</code>和<code>Fn2</code>和<code>Fn3</code>,这个类型的对象同时拥有这三种类型的成员。</p><p>来看一个混入(<code>mixins</code>)的例子:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">        (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> FnInterface &#123;</span><br><span class="line">    getName(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Fn2 <span class="keyword">implements</span> FnInterface &#123;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getName'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = extend(<span class="keyword">new</span> Fn1(<span class="string">"mickey"</span>), <span class="keyword">new</span> Fn2());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = f.name; <span class="comment">// mickey</span></span><br><span class="line"></span><br><span class="line">f.getName(); <span class="comment">// getName</span></span><br></pre></td></tr></table></figure><h3 id="联合类型-Union-Types"><a href="#联合类型-Union-Types" class="headerlink" title="联合类型(Union Types)"></a>联合类型(Union Types)</h3><p>联合类型表示一个值可以是几种类型之,用竖线 <code>|</code> 分隔每个类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWidth</span>(<span class="params">dom: <span class="built_in">any</span>, width: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    dom.style.width = width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型保护与区分类型-Type-Guards-and-Differentiating-Type"><a href="#类型保护与区分类型-Type-Guards-and-Differentiating-Type" class="headerlink" title="类型保护与区分类型(Type Guards and Differentiating Type)"></a>类型保护与区分类型(Type Guards and Differentiating Type)</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.swim) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改上面的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">    (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户自定义的类型保护</li></ul><p>TypeScript里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>typeof类型保护</li></ul><p>这些<strong>typeof类型保护</strong>只有两种形式能被识别：typeof v === “typename”和 typeof v !== “typename”， “typename”必须是 “number”， “string”， “boolean”或 “symbol”。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护</p><ul><li>instanceof类型保护</li></ul><p>instanceof类型保护是通过构造函数来细化类型的一种方式<br>instanceof的右侧要求是一个构造函数，TypeScript将细化为:</p><ul><li>此构造函数的 prototype属性的类型，如果它的类型不为 any的话</li><li>构造签名所返回的类型的联合</li></ul><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名就是给类型起一个新的名字,起别名不会新建一个类型，只是用新的名字来引用那个类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名也可以是泛型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123; value: T &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">    value: T;</span><br><span class="line">    left: Tree&lt;T&gt;;</span><br><span class="line">    right: Tree&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名不能出现在声明右侧的任何地方</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Yikes = <span class="built_in">Array</span>&lt;Yikes&gt;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">"ease-in"</span> | <span class="string">"ease-out"</span> | <span class="string">"ease-in-out"</span>;</span><br><span class="line"><span class="keyword">class</span> UIElement &#123;</span><br><span class="line">    animate(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (easing === <span class="string">"ease-in"</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-out"</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-in-out"</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement();</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"ease-in"</span>);</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"uneasy"</span>); <span class="comment">// error: "uneasy" is not allowed here</span></span><br></pre></td></tr></table></figure><p>字符串字面量类型还可以用于区分函数重载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createElement(tagName: "img"): HTMLImageElement;</span><br><span class="line">function createElement(tagName: "input"): HTMLInputElement;</span><br><span class="line"><span class="comment">// ... more overloads ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="built_in">string</span></span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... code goes here ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDie</span>(<span class="params"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态的this类型"><a href="#多态的this类型" class="headerlink" title="多态的this类型"></a>多态的<code>this</code>类型</h3><p>多态的 this类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回 this类型:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BasicCalculator &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> value: <span class="built_in">number</span> = 0</span>) &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> currentValue(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> add(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value += operand;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> multiply(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value *= operand;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... other operations go here ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> BasicCalculator(<span class="number">2</span>)</span><br><span class="line">            .multiply(<span class="number">5</span>)</span><br><span class="line">            .add(<span class="number">1</span>)</span><br><span class="line">            .currentValue();</span><br></pre></td></tr></table></figure><p>由于这个类使用了 this类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ScientificCalculator <span class="keyword">extends</span> BasicCalculator &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">value = 0</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> sin() &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="built_in">Math</span>.sin(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> ScientificCalculator(<span class="number">2</span>)</span><br><span class="line">        .multiply(<span class="number">5</span>)</span><br><span class="line">        .sin()</span><br><span class="line">        .add(<span class="number">1</span>)</span><br><span class="line">        .currentValue();</span><br></pre></td></tr></table></figure><h3 id="索引类型-Index-types"><a href="#索引类型-Index-types" class="headerlink" title="索引类型(Index types)"></a>索引类型(Index types)</h3><p>使用索引类型，编译器就能够检查使用了动态属性名的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">o, names</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Jarid'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = pluck(person, [<span class="string">'name'</span>]); <span class="comment">// ok, string[]</span></span><br></pre></td></tr></table></figure><p>上面代码引入了新的类型操作符<code>keyof T</code>,<code>索引类型查询操作符</code>和<code>T[K]</code>,<code>索引访问操作符</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personProps: keyof Person; <span class="comment">// 'name' | 'age'</span></span><br></pre></td></tr></table></figure><p>上面代码可以同通过<code>let personProps: &#39;name&#39; | &#39;age&#39;</code>替换,但是如果添加了新的属性到<code>Person</code>里面<code>keyof Person</code>会自动添加新增的属性,因此在使用前不清楚出现的属性名,就可以这样使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o[name]; <span class="comment">// o[name] is of type T[K]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getProperty</code>里的<code>o: T</code>和<code>name: K</code>，意味着<code>o[name]: T[K]</code>。 当你返回<code>T[K]</code>的结果，编译器会实例化键的真实类型，因此 <code>getProperty</code>的返回值类型会随着你需要的属性改变</p><p><code>keyof</code>和<code>T[K]</code>与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么<code>keyof T</code>会是<code>string</code>。 并且<code>T[string]</code>为索引签名的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Map&lt;T&gt; &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> keys: keyof Map&lt;<span class="built_in">number</span>&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> value: Map&lt;<span class="built_in">number</span>&gt;[<span class="string">'foo'</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>TypeScript提供了从旧类型中创建新类型的一种方式 — <strong>映射类型</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br></pre></td></tr></table></figure><p>它的语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分</p><ul><li>类型变量 K，它会依次绑定到每个属性</li><li>字符串字面量联合的 Keys，它包含了要迭代的属性名的集合</li><li>属性的结果类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NullablePerson = &#123; [P <span class="keyword">in</span> keyof Person]: Person[P] | <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">type</span> PartialPerson = &#123; [P <span class="keyword">in</span> keyof Person]?: Person[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Nullable&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]: T[P] | <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br></pre></td></tr></table></figure><p>上面代码是真正应用中使用到的</p><p>上面介绍了高级类型种的10种类型,这也是日常我们会用到的</p><p>上面我们介绍了<code>TypeScript</code>的高级类型，第十节我们将介绍Symbols</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(八) - 类型推断</title>
      <link href="/2018/10/15/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%85%AB)%20-%20%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/"/>
      <url>/2018/10/15/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%85%AB)%20-%20%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p><code>typescript</code>类型是在那里如何被推断的？<br><a id="more"></a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们声明变量时不指定变量类型，<code>TypeScript</code>会进行类型推断来帮助我们提供类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> </span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'string'</span></span><br></pre></td></tr></table></figure><p>上面代码中变量<code>a</code>,<code>b</code>分别会被类型推断推断为<code>number</code>和<code>string</code></p><p>但是有的情况类型推断无法自动推断出类型,下面小节会介绍</p><h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><p>当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断一个最适合的通用类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure><p>为了推断变量<code>a</code>的类型，我们必须考虑所有元素的类型。 这里有两种选择： <code>number</code>和<code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型</p><p>有时候候选类型共享相同的通用类型,但是却没有一个类型能做为所有候选类型的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = [<span class="keyword">new</span> Width(), <span class="keyword">new</span> Height(), <span class="keyword">new</span> Color()]</span><br></pre></td></tr></table></figure><p>上面代码我们想<code>style</code>被推断为<code>Style[]</code>类型,但是数组没有对象时<code>Style</code>类型,因此不能推断出结果，修改一下代码如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style: Style[] = [<span class="keyword">new</span> Width(), <span class="keyword">new</span> Height(), <span class="keyword">new</span> Color()]</span><br></pre></td></tr></table></figure><p><strong>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型<code>(Width | Height| color)[]</code></strong></p><h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mouseEvent.button);  <span class="comment">//&lt;- Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TypeScript</code>类型检查器使用<code>Window.onmousedown</code>函数的类型来推断右边函数表达式的类型,如果函数表达式不是在上下文类型的位置， mouseEvent参数的类型需要指定为any，这样也不会报错了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mouseEvent.button);  <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的类型推断，第九节我们将介绍高级类型</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(七) - 枚举</title>
      <link href="/2018/10/10/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%83)%20-%20%E6%9E%9A%E4%B8%BE/"/>
      <url>/2018/10/10/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%83)%20-%20%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举<br><a id="more"></a></p><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> des &#123;</span><br><span class="line">    top = <span class="number">1</span>,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了数字枚举,top使用初始化值为<code>1</code>,其余的成员就会从<code>1</code>开始自动增长</p><p>我们也可以不制定初始化值，那么<code>top</code>就会是<code>0</code>，其他成员就会从<code>0</code>开始增长</p><h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p> 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> des &#123;</span><br><span class="line">   top = <span class="string">'TOP'</span>,</span><br><span class="line">   right = <span class="string">'RIGHT'</span>,</span><br><span class="line">   bottom = <span class="string">'BOTTOM'</span>,</span><br><span class="line">   left = <span class="string">'LEFT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管<code>反向映射</code>(后面会讲解)会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字</p><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Des &#123;</span><br><span class="line">    top = <span class="number">1</span>,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">des: Des</span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(des) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(Des.top)</span><br></pre></td></tr></table></figure><h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h3><p>每个枚举成员都带有一个值，它可以是<code>常量</code>或<code>计算出来的</code>。 当满足如下条件时，枚举成员被当作是常量</p><ul><li><p>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值<code>0</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.X is constant:</span></span><br><span class="line"><span class="keyword">enum</span> E &#123; X &#125;</span><br></pre></td></tr></table></figure></li><li><p>它不带有初始化器且它之前的枚举成员是一个 数字常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加<code>1</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All enum members in 'E1' and 'E2' are constant.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> E1 &#123; X, Y, Z &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> E2 &#123;</span><br><span class="line">    A = <span class="number">1</span>, B, C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>枚举成员使用 常量枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式<ul><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li><li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li><li>带括号的常量枚举表达式</li><li>一元运算符<code>+</code>,<code>-</code>,<code>~</code>其中之一应用在了常量枚举表达式</li><li>常量枚举表达式做为二元运算符<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>,<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>&gt;&gt;&gt;</code>,<code>&amp;</code>,<code>|</code>,<code>^</code>的操作对象。 若常数枚举表达式求值后为<code>NaN</code>或<code>Infinity</code>，则会在编译阶段报错</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileAccess &#123;</span><br><span class="line">    <span class="comment">// constant members</span></span><br><span class="line">    None,</span><br><span class="line">    Read    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    Write   = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    ReadWrite  = Read | Write,</span><br><span class="line">    <span class="comment">// computed member</span></span><br><span class="line">    G = <span class="string">"123"</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p><ul><li>任何字符串字面量（例如：<code>&quot;foo&quot;</code>，<code>&quot;bar&quot;</code>，<code>&quot;baz&quot;</code>）</li><li>任何数字字面量（例如：<code>1</code>,<code>100</code>）</li><li>应用了一元 <code>-</code>符号的数字字面量（例如：<code>-1</code>,<code>-100</code>）</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ShapeKind &#123;</span><br><span class="line">    Circle,</span><br><span class="line">    Square,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: ShapeKind.Circle;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: ShapeKind.Square;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: Circle = &#123;</span><br><span class="line">    kind: ShapeKind.Square,</span><br><span class="line">    radius: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: E</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x !== E.Foo || x !== E.Bar) &#123;</span><br><span class="line">        <span class="comment">// Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行时的枚举"><a href="#运行时的枚举" class="headerlink" title="运行时的枚举"></a>运行时的枚举</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">    X, Y, Z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">obj: &#123; X: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Works, since 'E' has a property named 'X' which is a number.</span></span><br><span class="line">f(E);</span><br></pre></td></tr></table></figure><h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Enum.A;</span><br><span class="line"><span class="keyword">let</span> nameOfA = Enum[a]; <span class="comment">// "A"</span></span><br></pre></td></tr></table></figure><p>上面代码编译成<code>Javascript</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Enum;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Enum</span>) </span>&#123;</span><br><span class="line">    Enum[Enum[<span class="string">"A"</span>] = <span class="number">0</span>] = <span class="string">"A"</span>;</span><br><span class="line">&#125;)(Enum || (Enum = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> a = Enum.A;</span><br><span class="line"><span class="keyword">var</span> nameOfA = Enum[a]; <span class="comment">// "A"</span></span><br></pre></td></tr></table></figure><h3 id="const枚举"><a href="#const枚举" class="headerlink" title="const枚举"></a>const枚举</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h3><p>外部枚举用来描述已经存在的枚举类型的形状</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B,</span><br><span class="line">    C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的</p><p>上面我们介绍了<code>TypeScript</code>的枚举，第八节我们将介绍类型推论</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(六) - 泛型</title>
      <link href="/2018/10/09/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%85%AD)%20-%20%E6%B3%9B%E5%9E%8B/"/>
      <url>/2018/10/09/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%85%AD)%20-%20%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>维基百科</strong>  泛型是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型<br><a id="more"></a></p></blockquote><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>下面通过两个例子来介绍<code>泛型</code>的基础用法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不适用泛型的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子是没有使用泛型的情况，我们使用泛型修改代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过添加类型变量<code>T</code>，<code>T</code>帮助我们捕获用户传入的类型，之后我们就可以使用这个类型，函数在返回<code>T</code>,这样我们可以知道参数类型和返回类型是相同并且可以跟踪函数使用的类型信息</p><p>上面一个简单的例子就是最简单的<code>泛型</code>的写法，<code>&lt;&gt;</code>里面的<code>T</code>可以随意修改，不一定是<code>T</code></p><h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p>使用泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型，也就是说你必须把这些参数当做是任意或所有类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arg))</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面代码是一样的效果</strong></p><h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>):<span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = fn1</span><br></pre></td></tr></table></figure><p>我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> fn1Face&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1: fn1Face&lt;<span class="built_in">number</span>&gt; = fn1</span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Styles&lt;T&gt; &#123;</span><br><span class="line">    width: T;</span><br><span class="line">    height: T;</span><br><span class="line">    setStyle: <span class="function">(<span class="params">width: T, height: T</span>) =&gt;</span> object</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="keyword">new</span> Styles&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">fn1.width = <span class="number">100</span></span><br><span class="line">fn1.height = <span class="number">100</span></span><br><span class="line">fn1.setStyle = <span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>) </span>&#123;<span class="keyword">return</span> &#123;width,height&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的泛型，第七节我们将介绍枚举</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(五) - 函数</title>
      <link href="/2018/10/08/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%BA%94)%20-%20%E5%87%BD%E6%95%B0/"/>
      <url>/2018/10/08/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%BA%94)%20-%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块<br><a id="more"></a></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>TypeScript中的函数和JavaScript中的函数一样，可以创建匿名函数和有名字的函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="函数定义类型"><a href="#函数定义类型" class="headerlink" title="函数定义类型"></a>函数定义类型</h3><p>我们可以给每个参数添加类型,而且可以给函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们一般会省略它，但是为了提升代码可以读性，一般我喜欢加上返回类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123; <span class="keyword">return</span> x + y&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以定义参数为可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">x:<span class="built_in">number</span>, y?:<span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>通俗解释:<strong>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn1() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = &#123;</span><br><span class="line">    fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn.fn1() <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>JavaScript是个动态语言，JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">data: object | <span class="built_in">string</span> | <span class="built_in">any</span></span>): <span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码函数<code>fn1</code>接受一个参数,这个参数类型可以是对象，字符串或者其他类型，函数体内会根据接受的参数返回不同值</p><p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">data: object</span>): <span class="title">object</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">data: <span class="built_in">number</span></span>): <span class="title">boolean</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">data: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span></span><br><span class="line">    if(typeof data === 'object') &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fn1(&#123;&#125;)</span><br><span class="line">fn1(<span class="number">1</span>)</span><br><span class="line">fn1(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>这样改变后，重载的<code>fn1</code>函数在调用的时候会进行正确的类型检查</p><p>为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面</p><p>上面我们介绍了<code>TypeScript</code>的函数，第六节我们将介绍泛型</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a><br><a href="https://www.cnblogs.com/pssp/p/5216085.html" target="_blank" rel="noopener">彻底理解this</a><br><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">JavaScript中的this-阮一峰</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(四) - 类</title>
      <link href="/2018/10/07/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%9B%9B)%20-%20%E7%B1%BB/"/>
      <url>/2018/10/07/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E5%9B%9B)%20-%20%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>在传统<code>JavaScript</code>中类是基于原型模拟出来的类，在ES6中新增<code>class</code>关键字来书写基于类的面向对象(底层还是基于原型的方式)<br><a id="more"></a></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><blockquote><p>维基百科 -&gt; 在面向对象编程，类（英语：class）是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法</p></blockquote><ul><li>ES5中的模拟类:</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Fn1.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Fn1,</span><br><span class="line">    setAge: function(<span class="params">age</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ES6中的类</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    setAge(age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TypeScript中的类</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    setAge(age: <span class="built_in">number</span>): <span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    setAge(age: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Fn2 <span class="keyword">extends</span> Fn1&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="keyword">new</span> Fn2(<span class="string">'mickey'</span>, <span class="number">26</span>)</span><br><span class="line">fn1.setAge(<span class="number">27</span>) <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>继承我们可以通过关键字<code>extends</code>来继承</p><p>ES5中的继承方式推荐大家看一下阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">构造函数的继承</a></p><h3 id="public修饰符"><a href="#public修饰符" class="headerlink" title="public修饰符"></a>public修饰符</h3><p>C#要求必须明确地使用 public指定成员是可见的。 在TypeScript里，成员都默认为 public</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> setAge(age: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private修饰符"><a href="#private修饰符" class="headerlink" title="private修饰符"></a>private修饰符</h3><p>当成员被标记成 private时，它就不能在声明它的类的外部访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Fn1().name <span class="comment">// error 'name'是私有的</span></span><br></pre></td></tr></table></figure><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Fn2 <span class="keyword">extends</span> Fn1&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">       <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Fn2(<span class="string">'mickey'</span>).name <span class="comment">// error </span></span><br><span class="line"><span class="keyword">new</span> Fn2(<span class="string">'mickey'</span>).getName() <span class="comment">// mickey</span></span><br></pre></td></tr></table></figure><p><strong>我们不能在Fn1类外使用name，但是我们可以在派生出来的实例方法上使用name</strong></p><h3 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h3><p>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fn2(<span class="string">'mickey'</span>)</span><br><span class="line">f.name = <span class="string">'xxx'</span> <span class="comment">// error name是只读</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Fn1 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">    getName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码我们通过在<code>constructor</code>参数<code>private name: string</code>来进行创建和初始化,我们就声明和赋值合并在一起了，public和 protected的使用也是一样</p><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">"secret passcode"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">"secret passcode"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Error: Unauthorized update of employee!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    alert(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有<code>get</code>不带有<code>set</code>的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值</p><h3 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h3><p>我们可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Styles &#123;</span><br><span class="line">    <span class="keyword">static</span> width = <span class="number">200</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> style: object</span>) &#123;&#125;</span><br><span class="line">    getWidth() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Styles.width) <span class="comment">// 200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Styles(&#123;height: <span class="number">200</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Department &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printName(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Department name: '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span>; <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AccountingDepartment <span class="keyword">extends</span> Department &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'Accounting and Auditing'</span>); <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMeeting(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'The Accounting Department meets each Monday at 10am.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generateReports(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Generating accounting reports...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> department: Department; <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> Department(); <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment(); <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.printName();</span><br><span class="line">department.printMeeting();</span><br><span class="line">department.generateReports(); <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的类，第五节我们将介绍函数</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a><br><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">阮一峰Es6</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(三) - 接口</title>
      <link href="/2018/10/06/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%89)%20-%20%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/10/06/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%89)%20-%20%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约<br><a id="more"></a></p><h3 id="初次见面接口"><a href="#初次见面接口" class="headerlink" title="初次见面接口"></a>初次见面接口</h3><p>先看一段实例代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">styles: &#123;wdith: <span class="built_in">number</span>&#125;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(styles.wdith)</span><br><span class="line">&#125;</span><br><span class="line">fn1(&#123;width: <span class="number">100</span>, height: <span class="number">200</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码函数接受一个参数名<code>styles</code>里面有属性<code>width</code>类型是<code>number</code>,但是我们传了其他属性，编译器只会检查那些必需的属性是否存在，然而，有些时候TypeScript却并不会这么宽松</p><p>我们修改一下上面的例子，通过接口在实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">styles: Styles</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(styles.wdith)</span><br><span class="line">&#125;</span><br><span class="line">fn1(&#123;width: <span class="number">100</span>, height: <span class="number">200</span>&#125;) <span class="comment">// 这里会报错说height没有定义在接口中</span></span><br></pre></td></tr></table></figure><p><code>Styles</code>接口就是名字，用来描述上面例子里面的需求，它表示有一个<code>width</code>属性类型为<code>number</code>， 需要注意的是，我们在这里并不能像在其它语言里一样，说传给<code>fn1</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的</p><p><strong>类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以</strong></p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里面的属性不全部是必须的，我们可以不传一些参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span>,</span><br><span class="line">    height?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">styles: Styles</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(style)</span><br><span class="line">&#125;</span><br><span class="line">fn1(&#123;width: <span class="number">100</span>&#125;) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只是只读，你不能修改它的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    readonly width: <span class="built_in">number</span>,</span><br><span class="line">    readonly height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> styles: Styles = &#123;width: <span class="number">100</span>, height: <span class="number">200</span>&#125;</span><br><span class="line">styles.width = <span class="number">200</span> <span class="comment">// error widht是只读属性不能修改</span></span><br></pre></td></tr></table></figure><p>数组也可以创建只读，TypeScript具有ReadonlyArray<t>类型，可以确保数组创建后再也不能被修改：</t></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list1: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">list1 = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1 = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口可以描述对象也可以描述函数类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> fn1 &#123;</span><br><span class="line">    (width: <span class="built_in">number</span>, height: <span class="built_in">number</span>): object&lt;&#123;width: <span class="built_in">number</span>, height: <span class="built_in">number</span>&#125;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们定义了一个函数类型的接口，下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stylesFn: fn1</span><br><span class="line">stylesFn =  <span class="function"><span class="keyword">function</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; width,height &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如styles[0]或styles[“width”],可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> styles: Styles</span><br><span class="line">styles = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"><span class="keyword">let</span> width: <span class="built_in">number</span> = styles[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span>,</span><br><span class="line">    setStyle(s: object)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> CreateStyles <span class="keyword">implements</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    setStyle(s: object): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承，我们可以从一个接口复制成员到另一个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Styles1 <span class="keyword">extends</span> Styles &#123;</span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = &lt;Styles1&gt;&#123;&#125;</span><br><span class="line">s.color = <span class="string">'red'</span></span><br><span class="line">s.width = <span class="number">100</span></span><br><span class="line">s.height = <span class="number">200</span></span><br></pre></td></tr></table></figure><p>接口可以继承多个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Styles1 &#123;</span><br><span class="line">    border: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Styles2 <span class="keyword">extends</span> Styles, Styles1&#123;</span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = &lt;Styles2&gt;&#123;&#125;</span><br><span class="line">s.color = <span class="string">'red'</span></span><br><span class="line">s.width = <span class="number">100</span></span><br><span class="line">s.height = <span class="number">200</span></span><br><span class="line">s.border = <span class="string">'1px solid red'</span></span><br></pre></td></tr></table></figure><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>接口可以同时用于对象和函数使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Styles &#123;</span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    reset(): <span class="built_in">void</span></span><br><span class="line">    (style: object): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStyles</span>(<span class="params"></span>): <span class="title">Styles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> initStyle = &lt;Styles&gt;<span class="function"><span class="keyword">function</span>(<span class="params">style: object</span>)</span>&#123;&#125;</span><br><span class="line">    initStyle.width = <span class="number">200</span></span><br><span class="line">    initStyle.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用<code>JavaScript</code>第三方库的时候，你可能需要像上面那样去完整地定义类型</p><p>上面我们介绍了<code>TypeScript</code>的接口，第四节我们将介绍类</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(二) - 变量声明</title>
      <link href="/2018/10/05/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%BA%8C)%20-%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
      <url>/2018/10/05/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%BA%8C)%20-%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>在es5中js声明变量是通过<code>var</code>关键字进行变量声明，在es6中我们可以通过<code>let</code>,<code>const</code>两个关键字来进行声明，typescript中支持<code>let</code>,<code>const</code>进行声明变量<br><a id="more"></a></p><h3 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h3><p>在过去的js中(es5之前包括es5)我们声明变量是通过<code>var</code>来声明一个变量，但是var声明变量也有它不足的地方，我们接下来会详细介绍它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'mickey'</span></span><br></pre></td></tr></table></figure><p>通过上面的方式我们就声明了一个变量<code>a</code>类型是字符串值为<code>&#39;mickey&#39;</code><br>我们也可以在函数中声明变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是像<code>Java</code>,<code>C</code>等其他语言开发人员会对js中的var声明的变量作用域看起来很奇怪</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">flag: <span class="built_in">boolean</span></span>): <span class="title">void</span> | <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">26</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="literal">false</span>) <span class="comment">// return undefined</span></span><br><span class="line">fn1(<span class="literal">true</span>) <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>上面的例子中，变量<code>num</code>声明在<code>if</code>语句中，但是我们在语句的外面还是可以访问它，这是因为<code>var</code>声明可以包含在函数，模块，命名空间和全局作用域内部任何位置被访问，js通过var声明的变量是没有块级作用域</p><p>我们在看一个例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123; </span><br><span class="line">   a[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里我们点击a标签会输入 7</span></span><br><span class="line"><span class="comment">// 因为循环创建了i变量后面会直接覆盖前面的变量值</span></span><br></pre></td></tr></table></figure><p>为了解决上面的问题我们可以通过闭包来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i&lt;a.length; i++)&#123; </span><br><span class="line">   a[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(i);&#125;</span><br><span class="line">   &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方式通过es6中的<code>let</code>来解决,接下来我们详细介绍<code>let</code></p><h3 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h3><p>使用<code>let</code>和之前<code>var</code>声明变量一样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'mickey'</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = <span class="number">26</span></span><br></pre></td></tr></table></figure><p>我们通过<code>let</code>声明的方式解决上面的问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123; </span><br><span class="line">   a[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里我们点击a标签会输入 0,1,2,3,4,5,6,7</span></span><br></pre></td></tr></table></figure><p>如果你想了解比较详细<code>let</code>如果使用和新的特性你可以参考<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门-阮一峰</a></p><h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><p>使用<code>Const</code>和之前<code>var</code>声明变量一样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'mickey'</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">number</span> = <span class="number">26</span></span><br></pre></td></tr></table></figure><p>如果你想了解比较详细<code>Const</code>如果使用和新的特性你可以参考<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门-阮一峰</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><ul><li>数组解构</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">&#125;</span><br><span class="line">f(input);</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><ul><li>对象解构</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    a: <span class="string">"foo"</span>,</span><br><span class="line">    b: <span class="number">12</span>,</span><br><span class="line">    c: <span class="string">"bar"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; a, b &#125; = &#123; a: <span class="string">"baz"</span>, b: <span class="number">101</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面简单的介绍了数组解构和对象解构，如果你想详情了解还是推荐你去<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门-阮一峰</a>这个对ES6进行非常详细的介绍，相信你会学到很多ES6中所有新特性</p><p>上面我们介绍了<code>TypeScript</code>的变量声明，第三节我们将介绍接口</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门教程(一) - 基础类型</title>
      <link href="/2018/10/04/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%80)%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/04/typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%80)%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><code>Typescript</code>中的基础类型和<code>JavaScript</code>中定义的五种基本类型(<code>Number</code>,<code>String</code>,<code>Boolean</code>,<code>Undefined</code>,<code>Null</code>)几乎相同,还新增了枚举类型,接下来我们详细介绍<code>TypeScript</code>中的基础类型<br><a id="more"></a></p><h3 id="布尔值-Boolean"><a href="#布尔值-Boolean" class="headerlink" title="布尔值(Boolean)"></a>布尔值(Boolean)</h3><ul><li>布尔值类型就是简单的<code>true</code> or <code>false</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isShow: <span class="built_in">boolean</span> = <span class="literal">true</span> </span><br><span class="line"><span class="comment">// :后面是指定变量isShow的类型，如果修改了isShow的变量类型为非boolean值就会报错</span></span><br></pre></td></tr></table></figure><h3 id="数字-Number"><a href="#数字-Number" class="headerlink" title="数字(Number)"></a>数字(Number)</h3><ul><li><code>Typescript</code>中的数字类型和<code>Javascript</code>中的数字类型一样都是浮点数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">26</span></span><br><span class="line"><span class="keyword">let</span> money: <span class="built_in">number</span> = <span class="number">6000.04</span></span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span></span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span></span><br></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li><code>Typescript</code>中的字符串和<code>JavaScript</code>字符串写法一样都是通过双引号(<code>&quot;&quot;</code>)或者单引号(<code>&#39;&#39;</code>)表示字符串</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1: <span class="built_in">string</span> = <span class="string">'hi'</span></span><br><span class="line"><span class="keyword">let</span> str2: <span class="built_in">string</span> = <span class="string">"hi"</span></span><br></pre></td></tr></table></figure><h3 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h3><ul><li><code>Typescript</code>中<code>null</code>和<code>undefined</code>两个各自有自己的类型分别是<code>null</code>和<code>undefined</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// undefined和null是所有类型的子集，就是你可以把所有类型赋值成undefined和null</span></span><br></pre></td></tr></table></figure><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><ul><li><code>Typescript</code>里面的数组和JavaScript中一样都可以操作数组元素,在<code>Typescript</code>中有两种定义数组的方式</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一:</span></span><br><span class="line"><span class="keyword">let</span> list1: <span class="built_in">string</span>[] = [<span class="string">'name1'</span>, <span class="string">'name2'</span>, <span class="string">'name3'</span>]</span><br><span class="line"><span class="keyword">let</span> list2: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 方法二:</span></span><br><span class="line"><span class="keyword">let</span> list3: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'name1'</span>, <span class="string">'name2'</span>, <span class="string">'name3'</span>]</span><br><span class="line"><span class="keyword">let</span> list4: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h3><ul><li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">t = [<span class="string">'mickey'</span>, <span class="number">26</span>] <span class="comment">// ok</span></span><br><span class="line">t = [<span class="number">26</span>, <span class="string">'mickey'</span>] <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举(Enum)"></a>枚举(Enum)</h3><ul><li><code>enum</code>类型是在<code>JavaScript</code>类型中新增的类型, 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Style &#123;width, height, color&#125;</span><br><span class="line"><span class="keyword">let</span> warp: Style = Style.width</span><br></pre></td></tr></table></figure><p>默认情况下，枚举里面的值是从<code>0</code>开始为元素编号，也可以手动的指定成员的数值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Style &#123;width = <span class="number">1</span>, height = <span class="number">2</span>, color = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> wrap: Style = Style.width</span><br><span class="line"><span class="comment">// 也可以通过枚举的值得到它的名字</span></span><br><span class="line"><span class="keyword">let</span> wrap: Style = Style[<span class="number">2</span>] <span class="comment">// height</span></span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><ul><li>我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查就可以使用<code>any</code>类型来标记这些变量</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="string">'mickey'</span></span><br><span class="line">a = <span class="number">26</span></span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list1: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = [<span class="number">1</span>,<span class="string">'name1'</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p><strong><em>通过any定义的变量在后面可以随意赋值成其他类型的变量,这个就和js使用一样，js是弱类型语言定义变量可以不指定类型而且可以随意修改变量类型</em></strong></p><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><ul><li>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123; <span class="built_in">console</span>.log(<span class="string">'test...'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量为void 你只能为它赋值为 undefined和null</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">void</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><ul><li>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时</li><li>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们介绍了<code>TypeScript</code>的基础类型，第二节我们将介绍变量声明</p><blockquote><p>文章参考<a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">TypeScript中文网</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js原型继承五条基本原则</title>
      <link href="/2017/08/23/js%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BA%94%E6%9D%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
      <url>/2017/08/23/js%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BA%94%E6%9D%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>js中的原型继承，遵守5个基本原则：</p><ul><li>所有的数据都是对象</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li></ul><p>接下来我们将详细讲解这个5个基本原则…..</p><a id="more"></a><h3 id="所有的数据都是对象"><a href="#所有的数据都是对象" class="headerlink" title="所有的数据都是对象"></a>所有的数据都是对象</h3><p>js在设计的时候引入了java两套类型机制：<strong>基本类型</strong>和<strong>引用类型</strong></p><p>基本类型包括：<code>undefined、number、boolean、string、function、object</code></p><p>我们不能说js中所有的数据都是对象，但是可以说绝大多数的数据都是对象，那么相信在js中也一定会存在一个根对象(<strong>Object.prototype</strong>)</p><p>在js中根对象(<strong>Object.prototype</strong>)是一个空的对象，我们遇到的每一个对象都是从<strong>Object.prototype</strong>对象克隆而来，<strong>Object.prototype</strong>对象就是它们的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj_1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj_2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Object.getPrototypeOf来查看它们的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj_1) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj_2) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"><a href="#要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它" class="headerlink" title="要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"></a>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</h3><p>在js中我们并不需要关心克隆的细节，因为这些操作浏览器引擎内部已经实现了，我们只需要显式地调用<code>var obj = new Object()或者var obj = {}</code>，引擎会从<code>Object.prototype</code>上克隆一个对象出来。</p><p>我们也可以通过new操作符来创建一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name= name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Person(<span class="string">'anjie'</span>); <span class="comment">// 通过new操作符得到一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r.name);<span class="comment">//anjie</span></span><br><span class="line"><span class="built_in">console</span>.log(r.getName());<span class="comment">//anjie</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(r) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>我们通过new得到的对象具体做了什么？</strong><br>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4<br>个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性；</li><li>返回新对象；</li></ol><p>new操作符具体做了3件事<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空对象</span></span><br><span class="line"><span class="keyword">var</span> r = &#123;&#125;; </span><br><span class="line"><span class="comment">//将这个空对象的__proto__成员指向了Person函数对象prototype成员对象</span></span><br><span class="line">r.__proto__ = Person.prototype  </span><br><span class="line"><span class="comment">//将Person函数对象的this指针替换成r，然后再调用Person函数,给r添加属性和方法</span></span><br><span class="line">Person.call(r)</span><br></pre></td></tr></table></figure></p><p><strong>模仿new操作符</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> simulationNew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 从Objecet.prototype克隆一个对象</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>); <span class="comment">// 获取外部参数</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;<span class="comment">//指向正确的原型</span></span><br><span class="line">    <span class="keyword">var</span> newObj = Constructor.apply(obj,<span class="built_in">arguments</span>); <span class="comment">//借用外部传入的构造器给obj设置属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> newObj === <span class="string">'object'</span> ? newObj : obj; <span class="comment">//确保返回的永远是一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = simulationNew(Person,<span class="string">'anjie'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.name);<span class="comment">//anjie</span></span><br><span class="line"><span class="built_in">console</span>.log(a.getName());<span class="comment">//anjie</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h3><p>js给对象提供了一个名为<code>__proto__</code>的隐藏属性，某个对象的<code>__proto__</code>属性默认会指向它的构造器的原型对象，即<code>{Constructor.prototype}</code>,在一些浏览器中，<code>__proto__</code>被公开出来了(Chrome/Firefox)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>__proto__</code>就是对象跟对象构造器的原型联系起来的桥梁，正因为对象通过<code>__proto__</code>来记住的构造器的原型，我们上面模拟new操作符需要手动的给obj对象设置正确的<code>__proto__</code>指向</p><h3 id="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"><a href="#如果对象无法响应某个请求，它会把这个请求委托给它自己的原型" class="headerlink" title="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"></a>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</h3><p>在js中，每个对象都是通过<code>Object.prototype</code>克隆出来的，如果是这样的话我们只能得到单一的继承关系，即每个对象都是继承自<code>Object.prototype</code>对象，这样的对象显然是非常受限的。</p><p>js对象最初都是由<code>Object.prototype</code>克隆而来，但是对象构造器的原型并不仅限于<code>Object.prototype</code>上，而是可以动态指向其他对象，这样一来，但对象a需要借用b对象的能力时，可以选择性的把对象a的原型指向对象b，从而达到继承的效果。</p><p><strong>下面的代码是我们常用的原型继承方式：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'anjie'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">A.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.name);<span class="comment">//anjie</span></span><br></pre></td></tr></table></figure><p><strong>上面的代码引擎内部做了什么？</strong></p><ul><li>遍历对象a中的所有属性，但是没有name这个属性</li><li>查找name属性的这个请求委托对象a的构造器的原型，它被<code>a.__proto__</code>记录着并且指向<code>A.prototype</code>,而<code>A.prototype</code>被设置为对象obj</li><li>在对象obj中找到name属性，并返回它的值</li></ul><p><strong>当我们期望得到一个类继承自另一个类时</strong>我们通常会使用下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    name:<span class="string">'anjie'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="built_in">console</span>.log(b.name);<span class="comment">//anjie</span></span><br></pre></td></tr></table></figure><p><strong>上面的代码引擎内部做了什么？</strong></p><ul><li>遍历对象a中的所有属性，但是没有name这个属性</li><li>查找name属性的这个请求委托对象b的构造器的原型，它被<code>b.__proto__</code>记录着并且指向<code>B.prototype</code>,而<code>B.prototype</code>被设置为通过<code>new A()</code>创建出来的对象</li><li>在该对象中依然没有找到name属性，于是请求将继续委托给这个对象构造器的原型<code>A.prototype</code></li><li>在<code>A.prototype</code>中找到name属性，并返回它的值</li></ul><p>如果<code>A.prototype</code>中还没有知道name属性，请求会被传递给<code>A.prototype</code>的原型<code>Object.prototype</code>，如果没有name属性，会继续传递给<code>Object.prototype</code>的原型，<code>Object.prototype</code>的原型是<code>null</code>,所以会返回<code>undefined</code></p><p>ES6的中带来了新的<code>Class</code>语法，让js看起来更加想一门基于类的语言，其实背后还是通过原型机制来实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class manPerson extends Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> manPerson(<span class="string">'anjie'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.getName());<span class="comment">//anjie</span></span><br></pre></td></tr></table></figure><p>总结就写到这里了，本文简单介绍了js中原型继承的机制，希望通过学习的我们的学习总结笔记让大家也有收获，如果有什么不对的地方，望大家指点出来，我们共同学习。</p>]]></content>
      
      
      <categories>
          
          <category> js原型继承 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式单例模式</title>
      <link href="/2017/08/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/08/21/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是一种常见的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等。在js开发中，单例模式的用途同样非常广泛……<br><a id="more"></a></p><h3 id="JavaScript-设计模式-单例模式"><a href="#JavaScript-设计模式-单例模式" class="headerlink" title="JavaScript 设计模式-单例模式"></a>JavaScript 设计模式-单例模式</h3><h3 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h3><ul><li>定义：<code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</code></li></ul><h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><ul><li>原理：<code>用一个变量来保存当前是否已经为某个类创建对象，如果创建了就直接返回该对象，反之就重新实例化</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fn = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">Fn.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Fn(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = Fn.getInstance(<span class="string">'xxx'</span>);</span><br><span class="line"><span class="keyword">var</span> b = Fn.getInstance(<span class="string">'ooo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="透明的单例模式"><a href="#透明的单例模式" class="headerlink" title="透明的单例模式"></a>透明的单例模式</h3><p>我们创建一个CreateDiv单例类来负责在页面中创建唯一的div节点，实现一个<strong>‘透明’</strong>的单例类，用户从这个类中创建对象的时候，可以像使用任何普通类一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.html= html;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        <span class="keyword">return</span> instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> div = $(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>);</span><br><span class="line">        div.html(<span class="keyword">this</span>.html);</span><br><span class="line">        $(body).append(div);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CreateDiv;</span><br><span class="line">&#125;)()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> CreateDiv(<span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> CreateDiv(<span class="string">'two'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><pre><code>上面的代码实现了**透明**单例，但是也有它的缺点，上面我们使用了自执行函数和闭包，并且让这个匿名函数返回真正的构造函数，这样增加了一些程序的复杂度。如果某天我们需要利用这个类，在页面上创建很多个div，既要让这个单例类变成一个普通的可以产生多个实例，那我们就需要修改CreateDiv构造函数，把控制创建唯一对象的那段代码删除掉，这样就会刚给我带来一些不必要的麻烦，所有我们利用另外一种方式去实现，这种方式叫着**代理模式**,后面的笔记中我会详细介绍**代理模式**的具体实习方式</code></pre><h3 id="利用代理模式实现单例模式"><a href="#利用代理模式实现单例模式" class="headerlink" title="利用代理模式实现单例模式"></a>利用代理模式实现单例模式</h3><p>我们把上面的透明单例代码中间创建div部分代码移除出去，使他成为一个普通的创建DIV类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建div类</span></span><br><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.html = html;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateDiv.prototype = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = $(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>);</span><br><span class="line">    div.html(<span class="keyword">this</span>.html);</span><br><span class="line">    $(<span class="string">'body'</span>).append(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">var</span> ProxySingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CreateDiv(html);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ProxySingleton(<span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ProxySingleton(<span class="string">'two'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b );<span class="comment">//true</span></span><br></pre></td></tr></table></figure><pre><code>通过引入代理类的方式，我们也实现了单例模式，我们把负责管理单例的逻辑移到代理类**ProxySingleton**中，**CreateDiv**就变成一个普通类，它更**ProxySingleton**组合起来就可以实现单例模式的效果，这样的代码会更叫好维护。</code></pre><h3 id="JavaScript中的单例模式"><a href="#JavaScript中的单例模式" class="headerlink" title="JavaScript中的单例模式"></a>JavaScript中的单例模式</h3><ul><li>上面提到的创建单例模式，更多的是接近面向对象语言中的实现，单例对象从<strong>‘类’</strong>创建而来，在类为中心得语言中，这是很自然的做法。</li><li>在JavaScript中，其实是一门无类语言，没有类这个概念，在JS中创建单例模式方法很简单，我们只需要创建一个唯一的类。</li><li>全局变量不是单例模式，但是在js开发中，我们经常把全局变量当成单例模式来使用<h5 id="我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染"><a href="#我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染" class="headerlink" title="我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染"></a>我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染</h5></li></ul><ol><li><p>使用命名空间</p><h6 id="使用对象字面量的方式来创建："><a href="#使用对象字面量的方式来创建：" class="headerlink" title="使用对象字面量的方式来创建："></a>使用对象字面量的方式来创建：</h6> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = &#123;</span><br><span class="line">    a:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="使用动态创建命名空间"><a href="#使用动态创建命名空间" class="headerlink" title="使用动态创建命名空间"></a>使用动态创建命名空间</h6> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> My = &#123;&#125;;</span><br><span class="line">My.name = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parts = name.split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">var</span> current = My;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> parts)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!current[parts[i]])&#123;</span><br><span class="line">            current[parts[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current[parts[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">My.name = (<span class="string">'init'</span>);</span><br><span class="line">My.name = (<span class="string">'dom.style'</span>);</span><br><span class="line"><span class="comment">//上面创建结果等价于：</span></span><br><span class="line"><span class="keyword">var</span> My = &#123;</span><br><span class="line">    init:&#123;&#125;,</span><br><span class="line">    dom:&#123;</span><br><span class="line">        style:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用闭包封装私有变量</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __name = <span class="string">'anjie'</span>,</span><br><span class="line">        __age = <span class="number">25</span>,</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getUserInfo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> __name + <span class="string">'-'</span> + __age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="string">``</span><span class="string">`        </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">**我们使用下划线来约定私有变量__name和__age,他们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这样就避免了对全局的命令污染。**</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">###  通用单例模式     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">var</span> createDiv = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = $(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>);</span><br><span class="line">    div.html(<span class="string">'这个是测试div'</span>);</span><br><span class="line">    div.css(<span class="string">'display'</span>,<span class="string">'none'</span>);</span><br><span class="line">    $(<span class="string">'body'</span>).append(div);</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle(createDiv);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'loginBtn'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loginLayer = createSingleLoginLayer();</span><br><span class="line">    loginLayer.css(<span class="string">'display'</span>,<span class="string">'block'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>上面代码是一个通用的单例模式，我们在日常开发中可以直接利用这段代码来实现单例模式。</strong></p><hr><p><strong>以上代码借鉴于《JavaScript设计模式与开发实践》 – 曾探,这本书对设计模式进行的详细的介绍，推荐大家学习</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Javascript Function和函数学习笔记</title>
      <link href="/2017/08/16/function%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86/"/>
      <url>/2017/08/16/function%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>详细介绍javascript中函数的使用<br><a id="more"></a></p><h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>函数是由事件驱动的或者当它被调用执行的可复用的代码块</li></ul><p><code>js</code>支持两种函数：</p><ul><li>语言内部的函数（如<code>eval()</code>）</li><li>自己创建的函数</li></ul><p>在<code>js</code>函数内部声明的变量(使用<code>var</code>)是局部变量，只能在函数内部访问它<br>你可以在不同的函数声明相同的变量名称，因为它们是局部变量，两个不会相互影响</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>四种调用方式：</p><ul><li>作为函数</li><li>作为方法</li><li>作为构造函数</li><li>通过<code>call()</code>和<code>apply()</code></li></ul><h3 id="返回函数的函数"><a href="#返回函数的函数" class="headerlink" title="返回函数的函数"></a>返回函数的函数</h3><ol><li>当函数无明确返回值时，返回<code>undefined</code></li><li>当函数结束有<code>return</code>,返回什么就是什么</li></ol><p>我们可以利用<code>return</code>语句实现将函数返回值，或者单纯的结束函数<br>在使用了<code>return</code>的时候，函数会立即停止执行，如果<code>return</code>了值出去，函数的值就为返回的值</p><p><strong><em>函数通常会返回一个唯一值，这个值可能是另一个函数</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c = a +ｂ；</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());<span class="comment">//输出30；</span></span><br><span class="line"><span class="comment">//我们可以返回的函数赋值给你个变量</span></span><br><span class="line"><span class="keyword">var</span> fn1 = fn();</span><br><span class="line"><span class="built_in">console</span>.log(fn1);<span class="comment">//输出30；</span></span><br><span class="line"><span class="comment">//如果我们想返回的函数立即执行我们可以这样</span></span><br><span class="line"><span class="keyword">var</span> fn2 = fn()();<span class="comment">//在加一个括号表示立即执行函数</span></span><br></pre></td></tr></table></figure><p><code>js</code>函数传递参数都是按照值传递。</p><p><font color="red">引用类型</font>：</p><p><code>js</code>中引用类型都是存储在堆内存中的对象，变量中保存的实际只是一个指针，这个指针执行内存中的另一个位置，这个位置保存对象。</p><h3 id="创建匿名函数"><a href="#创建匿名函数" class="headerlink" title="创建匿名函数"></a>创建匿名函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我是一个没有名字的函数'</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>这种函数的好处是在我们只使用一次，省的在去定义一个函数名，避免命名冲突，<code>js</code>中没有命名空间的概念，因此有两个相同的函数名字，<code>js</code>会执行后面那个函数，因为<code>js</code>解析代码是一段一段的执行，他会按照最后出现的执行</p><ul><li>通过自我执行来执行匿名函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'打开程序我马上就执行啦！！！'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li>把匿名函数自我执行的返回值赋值给变量：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hi'</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">//输出hi</span></span><br></pre></td></tr></table></figure><ul><li>自我执行匿名函数的传参：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//输出10</span></span><br><span class="line">&#125;)(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="js创建动态函数"><a href="#js创建动态函数" class="headerlink" title="js创建动态函数"></a><code>js</code>创建动态函数</h3><p><code>js</code>支持创建动态函数，动态函数必须用<code>Function</code>对象来定义(Function是<code>js</code>中的一个对象，他是引用类型，是固定不变的，对象中的Function中的’F’必须大小）</p><p>创建动态函数的基本格式：<code>var 变量名 = new Function(&#39;参数1&#39;,&#39;参数2&#39;，&#39;参数n&#39;,&#39;执行语句&#39;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'var sum ; sum = x + y ; return sum;'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//输出5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的代码等同于：</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum;</span><br><span class="line">sum = x + y;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//输出5</span></span><br><span class="line"><span class="comment">//第一个函数是动态函数，第二个函数是静态函数</span></span><br></pre></td></tr></table></figure><p><strong><em>一般情况下我们不使用动态函数</em></strong></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数是一个函数的调用的过程，简单理解就是一个函数里面传参数，传的参数是一个函数，第一个函数执行完成后再去执行第二个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">fn1</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aa'</span>)；</span><br><span class="line">fn1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bb'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(fn1);</span><br><span class="line"><span class="comment">//先执行fn函数，fn函数执行完成后再执行fn1函数</span></span><br><span class="line"><span class="comment">//这里fn1函数就是回调函数</span></span><br></pre></td></tr></table></figure><h3 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">12</span>;   <span class="comment">// 变量：自由的</span></span><br><span class="line">arr.a= <span class="number">5</span>;     <span class="comment">//属性：属于一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)     //函数：自由的</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">alert(‘a’);</span><br><span class="line">&#125;</span><br><span class="line">arr.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)   //方法：属于一个对象</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">alert(‘b’);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>其实方法就是函数，只不过方法是所属的对象</em></strong></p><h3 id="JS全局函数"><a href="#JS全局函数" class="headerlink" title="JS全局函数"></a><code>JS</code>全局函数</h3><p>js中有7中全局函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>( )、<span class="built_in">eval</span>( )、<span class="built_in">isFinite</span>( )、<span class="built_in">isNaN</span>( )、<span class="built_in">parseFloat</span>( )、<span class="built_in">parseInt</span>( )、<span class="built_in">unescape</span>( )</span><br></pre></td></tr></table></figure><h3 id="函数的几个作用"><a href="#函数的几个作用" class="headerlink" title="函数的几个作用"></a>函数的几个作用</h3><ul><li>作为一个类构造器使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Class.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> item = <span class="keyword">new</span> Class();</span><br></pre></td></tr></table></figure><ul><li>作为闭包使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//独立的作用域</span></span><br><span class="line">&#125;)（）</span><br></pre></td></tr></table></figure><ul><li>作为构造函数调用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per1 = <span class="keyword">new</span> Person(<span class="string">'xiaoming'</span>,<span class="number">19</span>);</span><br><span class="line"><span class="keyword">var</span> per2 = <span class="keyword">new</span> Person(<span class="string">'xiaohong'</span>,<span class="number">20</span>);</span><br><span class="line">per1.name;<span class="comment">//输出'xiaoming'</span></span><br><span class="line">per1.age;<span class="comment">//输出19</span></span><br><span class="line">per2.name;<span class="comment">//输出'xiaohong'</span></span><br><span class="line">per2.age;<span class="comment">//输出20</span></span><br></pre></td></tr></table></figure><p>可以使用 new 运算符结合像 Object()、Date() 和 Function() 这样的预定义的构造函数来创建对象并对其初始化。面向对象的编程其强有力的特征是定义自定义构造函数以创建脚本中使用的自定义对象的能力。创建了自定义的构造函数，这样就可以创建具有已定义属性的对象。</p><p><strong><em>优缺点：</em></strong><br>使用构造器函数的优点是，它可以根据参数来构造不同的对象。 缺点是构造时每个实例对象都会生成重复调用对象的方法，造成了内存的浪费</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><ul><li><code>JS</code>中函数是一种语法，也是一个值，我们可以把函数赋值给一个变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFn = fn();</span><br><span class="line">fn(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//输出6</span></span><br><span class="line">newFn(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//输出12</span></span><br></pre></td></tr></table></figure><ul><li>函数也可以赋值给一个对象的属性，我们称为方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">//我们这里定义了一个空对象obj</span></span><br><span class="line">obj.seque = fn(<span class="number">2.3</span>);<span class="comment">//我们给空对象obj动态赋值了一个属性为seque</span></span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>这里的高阶函数可不是高数里的那个高阶函数，所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回新函数</p><h3 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h3><p>call()函数里面第一个参数是执行上下文，第二个是传递的参数。。。可以传递多个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">call</span>(<span class="params">this,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span>);</span></span><br></pre></td></tr></table></figure><p>apply()函数里面第一个参数是执行上下文，第二个是一个数组对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">apply</span>(<span class="params">this,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span>);</span></span><br></pre></td></tr></table></figure><p><strong><em>这部分后面还要完善，这里只是简单的介绍一下 add 2016.8.12</em></strong></p><h3 id="函数里面的参数-arguments"><a href="#函数里面的参数-arguments" class="headerlink" title="函数里面的参数(arguments)"></a>函数里面的参数(arguments)</h3><p>当函数被调用的时候，会得到一个参数数组，那就是<code>arguments</code>数组，通过它，函数可以访问所有它被调用时传递给它的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> i ,sum =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">sum+=<span class="built_in">arguments</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">4</span>,<span class="number">5</span>,<span class="number">23</span>,<span class="number">13</span>,<span class="number">35</span>,<span class="number">46</span>,<span class="number">-10</span>));<span class="comment">//116</span></span><br></pre></td></tr></table></figure><p><strong>实际上，arguments并不是一个真正的数组，它只是一个类数组的对象，它拥有一个length属性，但他缺少所有数组的方法。另外，arguments对象的长度是由传入的参数个数决定的，而不是由定义函数时的命名参数的个数决定的</strong></p><p><strong>函数在定义或者声明的时候，所有的参数都是形参，因此，我们可以根据实际情况来命名参数，函数也只有在被调用时才会传入实参。而每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments</strong></p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>函数的递归，即一个函数在通过名字调用自身的情况下构成的</p><h3 id="私有变量和私有函数"><a href="#私有变量和私有函数" class="headerlink" title="私有变量和私有函数"></a>私有变量和私有函数</h3><ul><li>定义在函数内部的变量和函数，如果不对外提供接口，外面是访问不到这些函数和变量的，这就叫做私有变量和私有函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;<span class="comment">//私有变量</span></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//私有函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFn = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(newFn.a);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(newFn.fn1);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="静态变量和函数"><a href="#静态变量和函数" class="headerlink" title="静态变量和函数"></a>静态变量和函数</h3><ul><li>当定义一个函数后通过点号 “.”为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Obj.num = <span class="number">72</span>;<span class="comment">//静态变量</span></span><br><span class="line">Obj.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//静态函数 </span></span><br><span class="line"></span><br><span class="line">alert(Obj.num);<span class="comment">//72</span></span><br><span class="line">alert(<span class="keyword">typeof</span> Obj.fn)<span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Obj();</span><br><span class="line">alert(t.name);<span class="comment">//undefined</span></span><br><span class="line">alert(<span class="keyword">typeof</span> t.fn);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="实例变量和函数"><a href="#实例变量和函数" class="headerlink" title="实例变量和函数"></a>实例变量和函数</h3><ul><li>在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，js也能做到这样</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a=[]; <span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">this</span>.fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Box.a); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Box.fn); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box=<span class="keyword">new</span> Box();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box.a); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box.fn); <span class="comment">//function</span></span><br></pre></td></tr></table></figure><p>为实例变量和方法添加新的方法和属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a=[]; <span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">this</span>.fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box1=<span class="keyword">new</span> Box();</span><br><span class="line">box1.a.push(<span class="number">1</span>);</span><br><span class="line">box1.fn=&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(box1.a); <span class="comment">//[1]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box1.fn); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box2=<span class="keyword">new</span> Box();</span><br><span class="line"><span class="built_in">console</span>.log(box2.a); <span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box2.fn); <span class="comment">//function</span></span><br></pre></td></tr></table></figure><p><strong>在box1中修改了a和fn，而在box2中没有改变，由于数组和函数都是对象，是引用类型，这就说明box1中的属性和方法与box2中的属性与方法虽然同名但却不是一个引用，而是对Box对象定义的属性和方法的一个复制。</strong></p><p><strong>这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢，prototype应运而生。</strong></p><h3 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h3><p><strong>基本概念：</strong></p><p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。</p><p>使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。</p><p>在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为原型链</p>]]></content>
      
      
      <categories>
          
          <category> javascript函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
